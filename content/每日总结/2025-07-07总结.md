- ##### 今天早饭吃了一个鸡蛋，一个煎饼喝了一碗豆浆，今天去联系了一下电信的工作人员以及校内驾校工作人员，交接了一下关于给新生推销产品的工作，我想到了正好可以利用我学习了视频剪辑的知识我推销一下我的产品来着，具体我想通过一个账号在各平台逐渐发布一些关于新生入校注意事项相关的内容，今天的Python学到for循环
- ![[Pasted image 20250708001927.png]]
- ##### 今天的两道编程题树形层级遍历和网格动态规划——展现了计算思维的深邃魅力，让我在解题过程中获得了诸多启发。在二叉树锯齿形层序遍历中，核心挑战在于保持BFS队列标准处理流程的同时实现输出方向的动态切换。具体实现时，我创建了一个基于链表的标准队列结构，队列节点包含二叉树指针和next指针，通过front和rear指针维护队列首尾。当处理每个层级时，我会先通过queue->size获取当前层节点数量，然后分配该层结果数组。这里的关键突破在于存储时的索引计算：对于第k层（k从0开始），当k为偶数时采用顺序存储（index = i），为奇数时则通过index = size-1 - i实现逆序存储。特别值得深入探讨的是内存管理的细节处理。每处理完一个节点后，我会立即释放出队的队列节点内存，但对于当前层的结果数组，则需保留到最终结果返回。当内存分配失败时，需要回滚释放所有已分配资源：不仅释放当前层数组，还要释放之前存储的所有层级结果，以及列大小数组。这种严谨性在大型树结构处理中尤为重要，比如当面对百万节点时，内存泄漏可能导致严重后果。测试过程中，我特别验证了非对称树结构如左倾树（left-heavy tree）的逆序存储正确性，确保在类似[[1],[3,2],[4,5,6]]这样的结构中，第二层能正确输出[3,2]而非[2,3]。面对机器人路径计数问题时，我面对的则是网格空间的动态规划挑战。初始思路很直观：创建二维DP数组，每个位置dp[i][j]存储到达(i,j)的路径数，状态转移方程为dp[i][j] = dp[i-1][j] + dp[i][j-1]。但当尝试实现100x100网格时，二维数组需要40KB内存（100*100*4字节），这促使我寻找优化方案。突破点在于发现计算第i行时只需第i-1行数据，于是将空间压缩为一维数组。在实现过程中，我还特别关注了边界条件的工程处理。
- ##### 今天的剪辑第二遍做到四分之三左右了，今天看了全球不知道的部分视频，感觉十分有趣，他的视频大部分以趣味科普为主，收集全世界的素材，再带上一点自己的口音的配音，让视频在给观众科普小知识的同时，又能像聊天一样轻松愉快，他视频还有个特点，就是总是把这个视频的主题或者最有趣的点作为视频的封面，关于他的文案则是先将有趣的部分提出，再在后文逐步叙述展开，让人能够被一条将近一分钟的视频所吸引
![[Pasted image 20250707171814.png]]
