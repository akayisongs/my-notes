- ### 今天早饭吃了一个鸡蛋喝了一杯豆浆还吃了一个包子，今天的解题思路根据老师的要求都写到了六百字以上，最近刷的算法题也是正在按照那个大佬的题单在跟着走，今天修改文章进行中，我在网上查了一下怎么用Python画一个折线图，但是发现如果直接套用模板死板又很容易出现障碍，应该把底层的pandas这些学会才能更好解决；
- ### 第一题是求每个元素的k半径子数组平均值。这道题的要求是返回一个全新的数组，新数组的每个位置对应原数组该位置的k半径平均值，对于那些无法形成完整半径的边界位置则用-1表示。它的难点在于，我们需要为数组中每一个“合法”的中心点都计算出一个平均值。如果用暴力法，对每个中心点都循环求和，复杂度会达到O(n * k)，效率很低。而滑动窗口的思路就非常巧妙，我先算出第一个有效窗口的总和，然后窗口向右每滑动一格，就用上一个窗口的和减去离开的元素，加上新进来的元素，用O(1)的代价更新总和，从而将总复杂度降到了O(n)。这个过程中，提前将结果数组全部置为-1，是一个处理边界情况的简洁技巧。第二题是求长度为k的连续子数组的最大平均数。这道题的目标发生了变化，它不再需要我求出所有子数组的平均值，而是只关心那个“最大”的平均值是多少，返回一个数字即可。虽然目标不同，但核心思想和第一题是完全一致的。因为所有子数组的长度都是固定的k，所以求最大平均数就等价于求最大和的子数组。我依然使用滑动窗口来高效地计算和更新每个窗口的总和，只是在每一步更新后，不再是记录平均值，而是用一个变量来追踪和维护遇到的最大窗口总和。直到遍历完整个数组，我才用这个记录下来的最大总和去除以k，得到最终答案。这样做还能避免在循环中反复进行浮点数除法。总的来说，这两道题让我深刻体会到，虽然题目的具体要求千变万化，但底层的算法思想是相通的。识别出“固定大小窗口”这个模型，并熟练运用滑动窗口来优化求和过程，是解决这类问题的关键。同时，处理好边界情况和注意数据溢出风险，也是写出正确代码的重要一环；
- ### 今天剪辑的第一个视频是迷你小屋搭建续集，第二个视频是榫卯结构工艺的视频
- 