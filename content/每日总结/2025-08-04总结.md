- ##### 今天早饭吃了一个鸡蛋一杯豆浆，最近天气太热了，出去吃个饭都能把人热死🥲，最近学Python的时候发现mooc最后讲的老师老念PPT，讲的很不清楚，于是我都是在b站上找的视频来学习了，学到了类和对象中面向对象的三大特点以及重写和钻石继承相关内容，web前端开发学到背景超链接样式；
- ![[Pasted image 20250805092008.png]]
- ![[Pasted image 20250805092143.png]]
- ##### 今天的两道编程题树形层级遍历和网格动态规划——展现了计算思维的深邃魅力，让我在解题过程中获得了诸多启发。在二叉树锯齿形层序遍历中，核心挑战在于保持BFS队列标准处理流程的同时实现输出方向的动态切换。具体实现时，我创建了一个基于链表的标准队列结构，队列节点包含二叉树指针和next指针，通过front和rear指针维护队列首尾。当处理每个层级时，我会先通过queue->size获取当前层节点数量，然后分配该层结果数组。这里的关键突破在于存储时的索引计算：对于第k层（k从0开始），当k为偶数时采用顺序存储（index = i），为奇数时则通过index = size-1 - i实现逆序存储。特别值得深入探讨的是内存管理的细节处理。每处理完一个节点后，我会立即释放出队的队列节点内存，但对于当前层的结果数组，则需保留到最终结果返回。当内存分配失败时，需要回滚释放所有已分配资源：不仅释放当前层数组，还要释放之前存储的所有层级结果，以及列大小数组。这种严谨性在大型树结构处理中尤为重要，比如当面对百万节点时，内存泄漏可能导致严重后果。测试过程中，我特别验证了非对称树结构如左倾树（left-heavy tree）的逆序存储正确性，确保在类似[[1],[3,2],[4,5,6]]这样的结构中，第二层能正确输出[3,2]而非[2,3]。面对机器人路径计数问题时，我面对的则是网格空间的动态规划挑战。初始思路很直观：创建二维DP数组，每个位置dp[i][j]存储到达(i,j)的路径数，状态转移方程为dp[i][j] = dp[i-1][j] + dp[i][j-1]。但当尝试实现100x100网格时，二维数组需要40KB内存（100*100*4字节），这促使我寻找优化方案。突破点在于发现计算第i行时只需第i-1行数据，于是将空间压缩为一维数组。在实现过程中，我还特别关注了边界条件的工程处理；
- ##### 今天剪辑的第一个视频是林中竹屋系列最后一个视频，第二个视频是关于室内趣味装修的解压视频