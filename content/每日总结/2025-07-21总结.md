- ##### 今天早饭吃了一根玉米一杯牛奶一个鸡蛋，今天继续了昨天视频的后续，估计这段素材还有两到三次剪完成，最近感觉回来有好久没咋锻炼了，有点长胖了，感觉有的时候还需要多锻炼才行，今天的Python学到多行文件读写，web前端开发学到sublime text的基本操作了
- ![[Pasted image 20250722085908.png]]
- ![[Pasted image 20250722090037.png]]
- ##### 今天的两道编程题，对于缺失的第一个正数问题，核心挑战在于如何在O(n)时间和O(1)空间内定位未排序数组中缺失的最小正整数。最初尝试的暴力解法——反复扫描数组寻找递增的最小正整数——暴露出O(n²)时间复杂度的缺陷，而常规排序方案也无法满足O(n)要求。突破点来自一个关键洞察：数组索引本身可作为天然哈希键。通过原地交换操作，将有效正整数x精准放置到索引x-1位置，从而把数组转化为自包含的哈希表。实现时需精心处理三个关键细节：持续检查交换后新元素避免遗漏，跳过无效值（负数/超大数）保持效率，以及通过目标位置值校验防止重复元素导致的死循环。第二次扫描时首个索引与值不匹配的位置（i+1）即是答案，若全匹配则返回n+1。这种"原地哈希"技巧深刻揭示了如何创造性利用输入结构本身存储状态信息，突破空间限制。会议室安排问题则要求计算时间区间集合的最大重叠深度，本质是寻找时间轴上同时进行的最大会议数。直观的时间轴遍历法因可能涉及百万级时间点而被否决。转折点在于认识到：会议室数量变化仅由离散的会议起止事件驱动。提取所有起止时间分别排序后，采用双指针模拟时间流——当开始时间指针领先时增加会议室计数并更新峰值；当结束时间指针领先或持平时减少计数。这里尤为精妙的是处理时间相等的边界情况：严格遵循"结束优先于开始"原则，确保会议室即时释放后被新会议复用。这种扫描线算法将连续问题转化为离散事件处理，通过O(n log n)排序和O(n)双指针遍历，优雅避免了O(max_time)的庞大开销。
- ##### 今天继续在上个视频的基础上剪辑了续集，感觉效率依旧还是比不上之前，还需要多研究研究人家的剪辑的视频和原素材的关系
- 