- ##### 今天早饭吃了一个鸡蛋喝了一杯牛奶，今天的解题思路根据老师的要求都写到了六百字以上，今天学习了老师推荐的Python课程，学了前五个视频，感觉确实这个老师讲的比较生动也会举一些生活中常见的例子来解释，包括里面给我们看的那个公益视频也非常有内容，不再是之前浙大视频后面几个老师那种仅仅念PPT的感觉了，今天web前端开发学到弹性盒子样式了，ae昨天学的不多今天要加紧学了；
- ![[Pasted image 20250818091204.png]]
- ![[Pasted image 20250818091313.png]]
- ##### 在算法学习中，链表插入排序和最大正方形这两道题虽然出发点不同，但都体现了算法设计的核心思想：如何将复杂问题拆解为更可控的子问题，并在此基础上寻求稳定高效的解决路径。链表插入排序的问题在于，链表不像数组可以随机访问，因此插入操作并非单纯移动元素，而是指针关系的重新调整。解决过程中，我们需要考虑多个关键问题：如何在已排序部分找到合适插入位置、如何避免在插入时破坏链表结构、如何处理链表头节点的特殊情况，以及如何保证插入操作后链表依旧连贯有序。最终采用虚拟头节点的技巧，将“插入到头部”的特殊情况统一化，同时通过维护前驱指针，在 O(1) 的代价下完成局部指针的更新。虽然整体时间复杂度为 O(n²)，但通过精细的指针操作，我们既解决了稳定排序的需求，又加深了对链表数据结构的理解。与此相比，最大正方形则是一道典型的动态规划题。问题的核心在于：如何避免暴力枚举所有可能子矩阵，从而高效找到只包含‘1’的最大正方形。暴力法需要穷举所有位置和边长，时间复杂度过高，不具备可行性。动态规划的突破点在于对状态的精确定义：令 dp[i][j] 表示以 (i, j) 为右下角的最大正方形边长。通过观察发现，一个正方形能否成立，取决于其左、上、左上三个方向的最小约束，因此状态转移公式为 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1。当 matrix[i][j] 为 ‘0’ 时，显然 dp[i][j] = 0，直接跳过即可。遍历整个矩阵的过程中，不断更新最大边长，最终得到最大正方形的面积。该方法时间复杂度为 O(mn)，空间复杂度为 O(mn) 或 O(n)，相较暴力解法有质的飞跃；
- ##### 今天剪辑的第一个视频是关于林中雪屋的续集，第二个视频是老师说的科普小视频
- 