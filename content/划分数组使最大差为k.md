![[Pasted image 20250712213903.png]]
### 思路：
题目要求将数组划分成最少的子序列，每个子序列中最大值与最小值的差不超过k，且保持原始相对顺序。这让我联想到分组类问题常见的贪心策略。==但贪心策略是否有效？==关键要看问题是否具有最优子结构。我想到背包问题中的贪心失效案例，但这里不同——因为子序列的划分不受顺序约束（只要保持原始相对顺序），而最值约束本质是数值范围的限制。于是我开始考虑：==如果先对数组排序，是否会影响问题本质？==排序会打乱顺序，但注意到题目只要求子序列保持原始顺序，并不要求子序列本身有序。这意味着我可以先通过排序获得全局视角，再通过合理分组还原顺序约束。
既然排序可行，==接下来该思考如何分组？==最理想情况是全部元素都在一个子序列，但通常受k限制无法实现。那么核心问题变成：==如何用最少的"数值容器"装下所有元素，每个容器容纳的数值范围不超过k？==这让我联想到区间覆盖问题——把排序后的数组看作数轴上的点，我需要用最少的长度为k的区间覆盖所有点。但仔细一想又不对：区间覆盖通常要求区间连续，而这里每个容器（子序列）可以包含非连续点，只要数值在[min, min+k]范围内就行。==那是否意味着可以跳着选点？==不可以，因为还有原始顺序约束，这又把我拉回现实：虽然排序后分组，但组内元素在原始数组中的相对顺序必须保留。不过幸运的是，只要我按排序顺序分组，然后按原始索引分配元素，顺序自然满足——因为组内元素在原始数组中的出现顺序不会因为被分到同组而改变。
现在问题简化为：在排序数组上，用最少的分组覆盖所有元素，每组满足最大元素减首元素≤k。==为什么是首元素？==因为在有序数组中，每组的最小值必然是组内第一个元素。那么贪心策略就呼之欲出了：从最小元素开始，尽可能多地包含后续元素，直到某个元素超出当前组的范围（即当前元素-组首元素>k），就开启新组。==但为什么必须用组首元素作为基准？==我尝试设想替代方案：比如用当前组最大值判断。设当前组最大为M，新元素x，若x≤M+k则可加入。但这样会导致过度扩张——例如[1,10,11],k=1：首元素1，加入10（10-1>1不成立？重新设计案例）。取[1,2,4,5],k=2：若首组[1,2]，遇到4时，若用当前最大值2判断，4-2=2≤2则加入，组变为[1,2,4]；接着5-4=1≤2加入，最终一组。但这是错误的，因为组内max=5,min=1,差4>k。而正确分组应为[1,2]和[4,5]。可见必须始终以组首元素为基准，才能严格控制数值范围。
最后考虑边界情况：空数组直接返回0；单元素数组自然为一组。但还有个隐含问题：当遇到超大跨度时如何处理？比如[1,100,101],k=1。排序后[1,100,101]：首组[1]，100-1>1开新组[100]，101-100≤1加入第二组。结果两组，正确——因为1和100不可能同组。
### 细节：
- **如何处理数值突变和边界情况？**
   - **数值突变**：当`nums[i]-start>k`时立即开新组，并将`start`更新为当前元素。例如[1,100,101], k=1：  
    排序后1→100（差99>1）→ 开新组；100→101（差1≤1）→ 分组为[1]、[100,101] 
   - **空数组**：直接返回0
   - **单元素数组**：极差为0，必然1组
   - **重复元素**：[1,2,2,3], k=1：组首1，2-1≤1可加入，第二个2同样，3-1=2>1开新组 → [1,2,2]和[3] 
### 步骤：
1. **排序数组**  
    首先对输入数组进行升序排序。通过将元素按值从小到大排列，我们获得全局视角，便于后续基于数值范围进行分组。排序后，相邻元素的值差最小化，为高效分组奠定基础；
2. **初始化关键变量**
    - 设置子序列计数器 `ans = 1`：表示至少需要1个子序列（空数组特殊处理直接返回0）
    - 记录当前子序列起始值 `start = nums[0]`：将排序后的首个元素作为第一个子序列的最小值基准；
3. **遍历有序数组**  
    从索引1开始（`i = 1`）遍历排序后的数组，对每个元素 `nums[i]` 执行：
    - **差值检查**：计算 `nums[i] - start`
    - **阈值判断**：
        - 若差值 `> k`：开启新子序列 → `ans++`，并更新 `start = nums[i]`
        - 若差值 `≤ k`：将当前元素纳入原子序列 → 保持 `start` 不变；
4. **动态更新分组基准**  
    每当开启新子序列时，将当前元素作为新组的起始值。这保证：
    - 每个子序列的极差计算始终以组内最小值为基准
    - 后续元素只需与当前组起始值比较，无需回溯历史数据；
5. **返回最终结果**  
    遍历完成后，计数器 `ans` 的值即为满足条件的最少子序列数目，直接将其作为结果返回。
下面是代码的具体实现：
![[Pasted image 20250713020028.png]]
### 知识点：
贪心、数组