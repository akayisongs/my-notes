### 1
设有两个长度均为 n 的一维整型数组 A 和 res，对数组A 中的每个元素A[i]，计算 A[i] 与 A[j]（0 ≤ i ≤ j ≤ n-1）乘积的最大值，并将其保存到 res[i]中。 例如，若 A[i] = {1, 4, -9, 6}，则得到res[i] = {6, 24,81,36}。 现给定数组 A，请设计一个时间和空间上尽可能高效的算法calMulMax，求 res 中各元素的值。函数原型为：void calMulMax(int A[], int res[],intn)， 要求：
1) 给出算法的基本设计思想。 
2) 根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。
3) 说明你所设计算法的时间复杂度和空间复杂度。

1）核心思想是动态更新当前后缀子数组的极值信息。在处理每个元素 A[i] 时，我们已掌握其后所有元素的关键信息，通过两个变量：后缀最大值 max_suffix 和后缀最小值 min_suffix。根据数学中乘积运算的特性（正数乘正数得正数，负数乘负数也得正数），当 A[i] 非负时，其与后续元素的最大乘积必然是 A[i] 与后缀最大值的乘积；而当 A[i] 为负时，最大乘积则来自 A[i] 与后缀最小值的相乘。在遍历过程中，我们会先将当前元素纳入后缀极值范围，这样自然包含了元素自乘的情况。
2）![[Pasted image 20250624151923.png]]
3）时间复杂度：O(n)，算法只需要从后向前遍历数组一次；空间复杂度：O(1)，除了输入数组A和输出数组res外，算法只使用了常数级别的额外空间。

### 2
请设计一个队列，要求满足：初始时队列为空；入队时，允许增加队列占用空间；出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；入队操作和出队操作的时间复杂度始终保持为 O(1)。请回答：
1) 该队列是应选择链式存储结构，还是应选择顺序存储结构？
2) 画出队列的初始状态，并给出判断队空和队满的条件。
3) 画出第一个元素入队后的队列状态。 
4) 给出入队操作和出队操作的基本过程。

1）应选链式存储结构
2）![[Pasted image 20250624171029.png]]
队空条件：front == NULL
队满条件：理论不会队满，除非没有内存空间了
3）![[Pasted image 20250624170727.png]]
4）**入队操作**：
1. 检查空闲链表是否有可用节点
2. 若无则申请新节点，若有则从空闲链表取节点
3. 将新数据存入节点
4. 将节点链入队列尾部
   **出队操作**：
5. 检查队列是否为空
6. 从队头取出节点
7. 将节点加入空闲链表
8. 返回节点数据

### 3
设包含 4 个数据元素的集合 S= {'time', 'flies', 'so', 'fast'｝，各元素的查找概率依次为=0.35, = 0.15, = 0.15, = 0.35。
1) 若采用顺序存储结构保存 S, 且要求平均查找长度尽可能短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？
2) 若采用链式存储结构保存 S, 且要求平均查找长度尽可能短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？

1）**元素排列方式**：将查找概率最高的元素放在最前面；**查找方法**：从前往后的顺序查找；**ASL**= (0.35×1) + (0.35×2) + (0.15×3) + (0.15×4)= 0.35 + 0.7 + 0.45 + 0.6 = 2.1
2）**元素排列方式**：将查找概率最高的元素放在最前面；**查找方法**：从链表头开始的顺序查找；**ASL**：与顺序存储相同，为 2.1

### 4
（起评分 36）根据哈夫曼编码原理，实现一款文本文件的压缩软件，要求具有压缩和解压功能。简述：
(1) 实现思路； 
(2) 采用的存储结构； 
(3) 编写代码实现压缩和解压（包括代码和运行结果的截图）；
(4) 分析代码的时间复杂度和空间复杂度。

(1)压缩过程：
    读取文本文件内容到字符串
    统计每个字符出现的频率
    根据字符频率构建哈夫曼树
    生成字符到二进制编码的映射表
    将文本内容转换为二进制编码字符串
    将哈夫曼树和编码后的数据保存到压缩文件
   解压过程：
    从压缩文件中读取哈夫曼树结构
    读取编码后的二进制字符串
    使用哈夫曼树对二进制字符串进行解码
    将解码后的文本保存到输出文件
(2)二维数组和二叉树
(3)![[Pasted image 20250624214651.png]]
![[Pasted image 20250624214728.png]]
![[Pasted image 20250624214814.png]]
(4)**时间复杂度**：O(n)；**空间复杂度**：O(1)