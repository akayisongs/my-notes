![[Pasted image 20250712214422.png]]
### 思路：
普通栈已经支持O(1)的push/pop/top操作，但为什么获取最小值会成为瓶颈？回忆栈的基本特性——后进先出(LIFO)结构，我意识到当最小值被弹出后，次小值无法立即获取，必须重新扫描整个栈。这解释了为什么传统方法需要O(n)时间获取最小值。那么核心问题转化为：==如何在每次操作时动态维护最小值信息？==
接着我思考：==能否用单个变量记录最小值？==实验后发现根本缺陷——当最小值被弹出时，无法快速回溯到前次最小值。例如压入序列[3,1,2]：min=1；弹出2时min仍是1；但弹出1后min应变为3，此时却丢失了状态。这让我醒悟：必须保存历史最小值序列。那么新问题来了：==该用什么数据结构保存这些信息？数组？链表？还是...另一个栈？==
突然灵光一现：既然主栈本身具有LIFO特性，==最小值的更新是否也遵循后进先出规律？==验证这个猜想：当压入新元素val时，新最小值min_new = min(old_min, val)；弹出时最小值自动回退到前状态。于是解决方案浮出水面：用辅助栈同步记录主栈每个位置对应的最小值。这个认知突破让整个设计豁然开朗。==但具体如何实现呢？==我深入推演边界情况。当辅助栈为空时压入首个元素，最小值就是元素本身。当压入后续元素时，需要比较当前值与辅助栈顶：若val更小则辅助栈压入val，否则重复压入原最小值。==为什么要重复压入？==考虑序列[2,1,1]：第一次压入1时辅助栈变为[2,1]；第二次压入1时若辅助栈压入1，弹出第一个1后最小值会错误变为1（实际应仍是2）。通过重复压入原最小值，保证弹出时状态正确回退。这时我质疑：==额外使用整个栈的空间是否必要？==尝试优化空间效率。比如只在新最小值出现时压入辅助栈，非最小值不压入。但立即发现致命缺陷——弹出时无法判断是否移除了最小值。例如压入[3,1,2]，辅助栈只记录[3,1]；弹出2时辅助栈不变；弹出1时辅助栈弹出，最小值正确回退到3。但若继续压入[3,1,1]：辅助栈记录[3,1]；弹出第一个1时辅助栈弹出，最小值错误变为3（实际应仍是1）。可见必须为每个主栈元素保存对应最小值状态，空间优化不可行。最后考虑实现细节。C语言中需要动态数组管理栈容量：初始化时分配合理大小（如10），当栈满时realloc扩容（通常加倍）。特别注意指针边界，栈顶索引初始化为-1表示空栈，压入时先递增索引再存值。
### 细节：
- **如何避免动态数组的常见错误？**
   - **初始容量**：设置合理初值（如10）减少扩容次数
   - **扩容策略**：容量翻倍（`new_capacity = old_capacity * 2`）保证均摊 O(1) 时间
   - **栈顶指针**：初始化为 `-1` 明确标识空栈状态
   - **边界检查**：pop/top/getMin 只在非空栈调用（题目保证）
### 步骤：
1. **数据结构初始化**
    - 创建包含三个核心成员的结构体：主栈数组 `main_stack`、最小栈数组 `min_stack`、栈顶指针 `top`（初始化为-1表示空栈）和当前容量 `capacity`
    - 为主栈和最小栈分配初始内存空间（如容量10）；
2. **压栈操作 (push)**
    - 检查栈是否已满：若 `top == capacity-1` 则调用扩容函数
    - 栈顶指针自增：`top++`
    - 新元素存入主栈：`main_stack[top] = val`
    - 更新最小栈：
        - 若是首个元素（`top==0`）：`min_stack[top] = val`
        - 否则：比较新值与当前最小值，存入较小者  
            `min_stack[top] = (val < min_stack[top-1]) ? val : min_stack[top-1]`；
3. **弹栈操作 (pop)**
    - 直接移动栈顶指针：`top--`（无需实际删除数据）
    - 注意：题目保证只在非空栈上调用；
4. **获取栈顶元素 (top)**
    - 返回主栈当前栈顶元素：`main_stack[top]`
    - 注意：栈顶指针始终指向有效元素；
5. **获取最小值 (getMin)**
    - 返回最小栈当前栈顶元素：`min_stack[top]`
    - 该值始终是主栈当前所有元素的最小值
6. **动态扩容机制**
    - 当栈满时：容量扩大为两倍 `new_capacity = capacity * 2`
    - 使用 `realloc` 重新分配主栈和最小栈内存
    - 更新容量变量：`capacity = new_capacity`
7. **资源释放**
    - 依次释放主栈数组、最小栈数组和结构体内存
    - 防止内存泄漏
下面是代码的具体实现：
![[Pasted image 20250713024534.png]]
### 知识点：
栈