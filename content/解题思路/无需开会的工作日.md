![[Pasted image 20250711193604.png]]
### 思路：
对于这道题，因为会议可能有重叠，比如 [ [1,3],[2,4] ] 中第 2-3 天被两个会议覆盖，如果直接累加每个区间的天数（3 + 3 = 6），会错误地多算重叠部分。这让我想起处理时间区间问题的经验——重叠会导致重复计数，因此必须合并这些区间，形成一个无重叠的连续块。否则，结果会偏离真实值，就像在示例 2 中，如果未合并 [[2,4],[1,3]]，直接计算会得到 (3 + 3) = 6 天会议，但实际只有 4 天（合并后为 [1,4]），导致错误。想到这里，我意识到合并是必不可少的步骤，==那么如何高效地合并这些重叠区间呢？==毕竟，会议数组是乱序的，比如 [[5,7],[1,3],[9,10]]，如果直接遍历，很难判断哪些区间会交叉。这时，我回忆起算法中的常见技巧：排序是处理无序区间的钥匙。于是，我决定先按会议的开始时间升序排序，这样相邻区间更容易比较。例如排序后 [[1,3],[5,7],[9,10]] 变得有序，然后遍历时只需检查当前会议是否与上一个合并块重叠（即 start_i <= 上一块的 end）。如果是，就扩展合并块的结束时间（取 max(end)）；否则，开启一个新块。这个过程就像整理时间线，把碎片拼成连续段。
但排序和合并只是手段，==合并后怎么计算总会议天数？会不会遗漏边界情况？==因为合并后的区间代表会议覆盖的连续日期，比如 [[1,3],[5,7]] 合并后仍是两个独立块，总天数是 (3-1+1) + (7-5+1) = 6。然而，实际中会议可能超出 days 范围（如会议 [8,12] 但 days=10），所以我必须在累加时截断区间：如果结束时间 > days，则按 days 计算。此外，如果开始时间 > days，直接忽略整个区间。这步很关键，否则会多算无效天数。例如 days=5 时，会议 [4,6] 应只算第 4-5 天（2 天），而非 3 天。但马上想到另一个潜在陷阱：==初始排序是否足够处理所有重叠场景？==因为经验告诉我，排序虽能解决相邻重叠（如 [1,3] 和 [2,4]），但非相邻的交叉（如 [1,5] 和 [3,7]）也能通过遍历合并——只要按开始时间排序，遍历时比较当前与上一个块即可覆盖所有情况。例如 [[1,5],[3,7]] 排序后仍是 [[1,5],[3,7]]，遍历第一步合并为 [1,7]，无需额外操作。这得益于排序后区间的单调性：开始时间递增，确保后续区间要么重叠，要么完全分离。
现在，合并后的区间数组已准备好，==如何从这些区间推导最终结果？==毕竟，问题要求的是空闲天数而非会议天数。思路很直接：用总天数 days 减去会议覆盖的总天数。例如 days=10，会议覆盖 8 天，则空闲为 2 天。但要注意，会议覆盖天数必须严格在 [1, days] 内计算，且合并后区间无重叠，累加时不会重复。计算完覆盖天数后，结果就是 days - total_meeting_days。最后，我反思整个过程：==这个解法是否高效？能否优化？==考虑到会议数量 n，排序耗时 O(n log n)，合并和累加是 O(n)，整体 O(n log n) 在大部分场景可行；如果 n 很大，排序是瓶颈，但基于我的经验，qsort 等库函数已足够优化。此外，内存使用 O(n) 存储合并区间，也在可接受范围。至此，思路线清晰闭合——从理解重叠挑战开始，通过排序和合并消除重复，再谨慎计算覆盖天数，最终得出空闲日。这种自问自答不仅帮我厘清逻辑，还融入了对边界问题的警觉，确保代码稳健。
### 细节：
- **如何防止超出总天数范围导致的错误？**
   需严格**边界检查**：
   - 合并时仅处理起始 ≤ days 的区间（避免无效合并）
   - 累加每个区间天数时动态截断结束时间（`min(end, days)`）  
     _示例_：days=5 时，会议 [3,6] 仅计算 [3,5] 的 3 天而非 4 天。
- **如何正确计算会议覆盖的总天数？**
   合并后，对每个无重叠区间计算其在有效范围 **[1, days]** 内的天数：
   - 若区间起始 > days：跳过（如会议 [11,15] 但 days=10）
   - 若区间结束 > days：截断至 days（如会议 [8,12] 且 days=10 → 按 [8,10] 计算）
   - 单区间天数公式：`结束 - 起始 + 1`（如 [1,3] 覆盖 3 天）。
### 步骤：
1. **定义区间比较函数**  
    创建一个 `compare` 函数作为 `qsort` 的排序依据，使会议区间按开始时间升序排列。该函数接受两个指针参数，提取每个区间的起始时间并返回它们的差值（`a[0] - b[0]`），确保排序后会议按时间线组织；
2. **排序会议数组**  
    使用标准库的 `qsort` 函数对输入的 `meetings` 二维数组排序。传入数组指针、会议数量、每个元素的大小（`sizeof(int)*2`）以及比较函数指针，将乱序会议整理为时序结构（如 [[5,7],[1,3]] → [[1,3],[5,7]]）；
3. **分配合并区间内存**  
    动态申请内存空间存储合并后的区间。由于最坏情况下无重叠（合并后区间数=原会议数），使用 `malloc` 分配 `meetingsSize * sizeof(int[2])` 字节空间，创建二维数组 `merged` 准备存储合并结果；
4. **合并重叠区间**  
    遍历排序后的会议数组，使用索引 `index` 跟踪合并进度：
    - **首个区间**：直接加入 `merged` 数组
    - **后续区间**：检查当前会议起始 `s` 与上一合并区间结束 `last_end`
        - 若 `s <= last_end`：合并（更新 `last_end = max(last_end, e)`）
        - 否则：作为新区间加入 `merged`  
            _示例_：合并 [[1,3],[2,4]] → [1,4]；
5. **计算有效会议天数**  
    初始化 `total_meeting_days=0`，遍历合并后的区间：
    - **跳过无效区间**：若起始日 `s > days` 则终止循环
    - **边界截断**：若结束日 `e > days` 则设 `e=days`
    - **累加天数**：对有效区间计算 `e - s + 1` 并累加  
        _关键点_：确保只计算 [1, days] 范围内的天数（如会议 [8,12] 在 days=10 时按 [8,10] 算 3 天）；
6. **释放动态内存**  
    使用 `free(merged)` 释放步骤 3 申请的内存空间，避免内存泄漏。此操作在结果计算完成后进行；
7. **返回空闲天数**  
    最终结果通过公式 `days - total_meeting_days` 计算：
    - 总工作天数为 `days`
    - 减去会议覆盖的总天数 `total_meeting_days`
    - 返回差值即为无会议日（如 10-8=2）
下面是代码的具体实现：
![[Pasted image 20250711215519.png]]
![[Pasted image 20250711215544.png]]
### 知识点：
数组、排序