![[Pasted image 20250707211517.png]]
### 思路：
这道题和昨天骑士那道题目要求比较类似，就是每次机器人智能选择向右或者向下移动一个单位，这么看来这道题目更像一道数学题一点，==用数学的方法来是如何解决的呢？==这道题显然是一个排列组合的问题，结果是`m-1`个向下移动的项以及`n-1`个向右移动的项进行全排列的数量和，就假如`m=2 n=2`一共是两条路径，那用`(m-1+n-1)!`来计算即可得到路径数量为2，题目下方提示有提到动态规划的方法，==动态规划如何切入？==想象站在某个网格点(i,j)，到达这里的所有路径有什么共同点？显然，最后一步要么来自上方(i-1,j)，要么来自左侧(i,j-1)。==这不正是动态规划最优子结构的完美体现吗？==于是核心状态转移方程浮现：dp[i][j] = dp[i-1][j] + dp[i][j-1]。但此时新的疑问出现：==边界情况怎么处理？==当处于第一行或第一列时，只能沿直线走，这些位置都只有唯一路径。这就像站在墙边行走，没有其他选择。在构思实现时，内存优化成为关键挑战。二维DP数组需要O(mn)空间，当网格为100x100时就是10,000个元素。我琢磨：==能否压缩空间？==注意到计算当前行时只需上一行的数据，这提示可以用滚动数组，==如果只用一维数组呢？==我尝试在纸上模拟：初始化dp数组为全1（第一行状态），然后逐行更新。处理第二行时，dp[j]的新值等于旧dp[j]（上方路径）加上dp[j-1]（左方路径）空间复杂度竟能降到O(min(m,n))。
选择具体维度时我又迟疑：==用行数还是列数作为DP数组长度？==考虑到网格可能扁长或瘦高，应该取min(m,n)。例如3×7网格用长度3的数组就足够。接着验证这个方案：当处理到第i行第j列时，dp[j]恰好表示到达(i,j)的路径数。通过双重循环迭代，最终dp[min_dim-1]就是所求答案。这个过程如同搭积木，每块积木的位置都精确计算。最后思考特例处理。当m或n为1时，只有一条直线路径。有趣的是，这个特例完美融入通用方案：初始化全1的dp数组后，若max_dim=1则直接返回1。测试时我特别关注对称性：3×7和7×3的结果相同，验证了组合数学的C(m+n-2,m-1)性质。
### 细节：
- **组合数学解法：为什么动态规划更优？**
**组合公式**：路径数 = C(m+n-2, m-1)
**缺点**：
    阶乘计算易数值溢出
    需要处理大数运算
**DP优势**：自然处理整数计算，避免溢出风险
### 步骤：
1. **处理特殊边界情况**
    - 若网格行数 `m` 或列数 `n` 小于等于 0，直接返回 0
    - 若网格为 1×1 或单行/单列，返回 1（唯一路径）
2. **确定维度优化参数**
    - 计算较小维度：`min_dim = min(m, n)`
    - 计算较大维度：`max_dim = max(m, n)`
3. **初始化动态规划数组**
    int* dp = (int*)malloc(min_dim * sizeof(int));
    for(int i=0; i<min_dim; i++) 
        dp[i] = 1;  // 第一行/列的路径数均为1
4. **核心动态规划迭代**
    - 外层循环：遍历较大维度 (`i = 1 → max_dim-1`)
    - 内层循环：遍历较小维度 (`j = 1 → min_dim-1`)
    - 状态转移：`dp[j] += dp[j-1]`
    - _物理意义_：  
        `dp[j]`（更新前）= 上方的路径数  
        `dp[j-1]` = 左方的路径数
5. **获取最终结果**
    - 结果存储在 DP 数组末尾：`result = dp[min_dim-1]`
    - 释放 DP 数组内存：`free(dp)`
6. **返回计算结果**
    - 返回路径总数：`return result`
下面是代码的具体实现：![[Pasted image 20250708005042.png]]
### 知识点：
数学、动态规划