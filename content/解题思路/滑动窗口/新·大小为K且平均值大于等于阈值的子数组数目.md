![[Pasted image 20250905101919.png]]
## 思路：
这道题要求我们统计一个数组中，所有长度为k且平均值大于等于threshold的连续子数组的数量。看到“连续子数组”和“固定长度”，我的第一反应就是滑动窗口算法，但这具体的实现路径是怎样的呢？==最直接的想法是什么？==最直接的想法就是暴力求解：用一个外层循环确定所有子数组的起点，再用一个内层循环遍历k个元素来计算每个子数组的和与平均值，最后进行判断。但这样一来，时间复杂度会达到O(nk)。对于一个大数据集，这种效率显然是无法接受的。我的目标是找到一个只需要一次遍历就能解决问题的方法。==如何避免这种嵌套循环带来的高额成本呢？==关键在于，相邻的两个窗口（子数组）之间有大量的元素是重合的。如果我每次都重新计算窗口内所有元素的和，就做了大量的重复工作。一个更聪明的办法是，当我将窗口向右滑动一格时，只考虑发生变化的元素：一个元素离开了窗口，一个新元素进入了窗口。我只需要维护一个当前窗口内所有元素的和esum，每次滑动时，减去离开的元素值，再加上新进入的元素值，就可以在常数时间内更新esum。这正是滑动窗口算法的精髓。==如何在一个循环内同时处理窗口的形成和滑动？==我可以使用一个从头到尾的单次for循环来同时实现这两个过程。在循环的每一步，我首先将当前元素arr[i]加入esum。接着，我需要判断窗口是否已经“填满”。当遍历的索引i小于k-1时，窗口的长度还不足k，此时我不需要进行任何判断，只需继续累加元素即可。当索引i第一次达到k-1时，第一个完整的窗口就形成了。从这一刻起，直到循环结束，每一次迭代都代表着一个完整的、长度为k的窗口。==在窗口形成后，如何根据题意进行判断并为下一次迭代做准备？==当i >= k-1时，我就可以开始执行核心逻辑了。首先，根据题目要求，我需要计算当前窗口的平均值。这个很简单，就是average = esum / k。由于平均值可能是小数，我必须确保这里执行的是浮点数除法。然后，我将这个average与给定的threshold进行比较，如果average >= threshold，就将我的计数器加一。在完成对当前窗口的判断之后，我必须为下一次迭代做准备，也就是模拟窗口的“滑动”。当前窗口（结束于i）的最左边元素是arr[i-k+1]。在下一次迭代中（窗口将结束于i+1），这个元素就不在窗口内了。因此，我在本次迭代的末尾，需要将esum减去arr[i-k+1]的值。这样，在下一次迭代开始时，current_sum就已经准备好了，只需再加上新的元素arr[i+1]即可。这个“先判断，后移出”的顺序，确保了单循环的逻辑正确性，最终形成了一个高效的O(n)解决方案。
## 细节：
- 在对比了力扣上运行程序最短的代码后，我发现我的代码==距其还有一定差距==，为什么呢？
   仔细观察了它的代码后，我发现我和他的代码最大差距在于两点：
     1. 他在这个窗口填满前，是通过一个循环直接填满的，由于循环次数为固定的k所以对算法的时间效率影响并不大，而我的算法则使用了一个判断来跳过后续的结构，这样导致了比他多进行了k次判断的过程；
     2. 还有一点是我询问ai后得到的，也是影响最大的一点，就是他的代码通过一个简单的数学转化避免了浮点数运算，从而降低了不少时间复杂度，这是我始料未及的，我以后会注意。
## 步骤：
#### 1. 初始化状态变量

- **创建求和变量**：定义一个变量 `esum` (或 `current_sum`) 用于累加当前窗口内所有元素的和，并将其初始化为0。
- **创建计数器**：定义一个变量 `cnt` 用于统计符合条件的子数组数量，并将其初始化为0。
#### 2. 启动单循环遍历

- 使用一个 `for` 循环，让索引 `i` 从 `0` 开始，遍历整个输入数组 `arr` 直到结束。
- 这个单一的循环将同时负责窗口的初始填充和后续的滑动过程。
#### 3. 在循环内累加元素并填充窗口

- 在每次循环开始时，首先将当前元素 `arr[i]` 的值累加到 `esum` 中。
- 接着，判断窗口是否已满（即是否已包含 `k` 个元素）。通过条件 `if (i < k - 1)` 来检查。
- 如果窗口未满，则执行 `continue`，跳过后续的判断和滑动操作，直接进入下一次循环以继续填充窗口。
#### 4. 在窗口满后进行计算和判断

- 当索引 `i` 大于等于 `k-1` 后，每次循环都代表一个完整的窗口，此时执行以下操作：
    - **计算平均值**：使用 `(double)esum / k` 来计算当前窗口内元素的平均值，并存入浮点数变量 `avrg`。
    - **比较并计数**：将计算出的 `avrg` 与给定的 `threshold` 进行比较。如果 `avrg >= threshold`，则将计数器 `cnt` 加一。
#### 5. 更新窗口的和（“滑动”）

- 在完成对当前窗口的判断之后，为下一次迭代做准备。
- 从 `esum` 中减去**即将离开窗口**的最左边的元素 `arr[i - k + 1]`。
- 这样，在下一次循环开始时，`esum` 中已经移除了旧元素，只需加上新元素即可，从而实现了窗口的“滑动”。
#### 6. 返回最终结果

- 当 `for` 循环遍历完整个数组后，变量 `cnt` 中存储的就是所有满足条件的子数组的总数。
- 函数最后返回 `cnt` 的值。
下面是代码的具体实现：
![[Pasted image 20250905121157.png]]
## 知识点：
滑动窗口、数组