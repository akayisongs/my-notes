![[Pasted image 20250911090132.png]]
### 思路：
这道题要求我们在一个固定长度为 k 的子数组里找一个满足特定条件的最大和时，第一反应就是，这肯定又是滑动窗口的题目。暴力求解，也就是检查每一个长度为 k 的子数组，肯定会超时，而滑动窗口正是解决这类问题的好方法。这个问题的核心难点在于，除了要维护窗口内元素的和，还要同时维护一个更复杂的状态：窗口内不同元素的数量。==那么，在窗口滑动的过程中，我需要维护哪几个关键信息呢？== 很明显，有两个：第一是当前窗口内所有元素的总和 sum；第二是当前窗口内不同元素的个数 distinct_count。窗口的和更新起来很简单，每当窗口向右移动一格，我就用 sum 减去滑出窗口的旧元素，再加上新滑入的元素，这样就能快速更新。
==但真正的挑战是，如何高效地去维护那个 distinct_count 呢？== 我不能简单地用一个计数器。比如，当一个数字 7 滑出窗口时，我怎么知道窗口里是否还有其他的 7 呢？如果还有，那么不同元素的总数就不应该减少。为了解决这个问题，我需要一个能记录窗口内每种数字出现次数的数据结构。哈希表（或者在C语言里，如果题目给出的数字范围不大，用一个频率数组来模拟）是完美的选择。我可以创建一个频率表 freq_map，键是数组中的数字，值是它在当前窗口内出现的次数。
==有了频率表，distinct_count 的更新逻辑是怎样的呢？== 当一个新元素滑入窗口时，我在频率表中将它的计数值加一。如果它原来的计数值是0，变为1，这说明窗口里出现了一个全新的不同元素，此时我就将 distinct_count 加一。反之，当一个旧元素滑出窗口时，我在频率表中将它的计数值减一。如果它的计数值从1变为了0，这说明这种元素在窗口里已经不存在了，此时我就将 distinct_count 减一。通过这种方式，我可以在每次滑动时，都以 O(1) 的时间复杂度精确地更新不同元素的数量。
这样一来，整个算法的流程就变得非常清晰了：我先初始化第一个长度为 k 的窗口，计算出初始的 sum 和 distinct_count。然后，让窗口从左到右开始滑动。每滑动一步，我都用 O(1) 的时间更新 sum 和 distinct_count。在每一步，我都检查 distinct_count 是否大于等于 m。如果满足条件，我就用当前的 sum去更新我维护的全局最大和 max_sum。整个数组遍历一次，就能得到最终的答案。
### 细节：
- **如何高效地检查所有符合条件的子数组，避免超时？**
	暴力方法是逐一检查所有长度为 `k` 的子数组，但效率太低。因为子数组的长度是固定的，所以这是使用 **滑动窗口算法** 的典型场景。通过维护一个大小为 `k` 的窗口，在数组上从左到右滑动，每次只更新变化的部分，从而将时间复杂度从 O(N * k) 降低到 O(N)。
### 步骤：
1. 初始化一个空的频率表，一个记录当前窗口和的变量 `current_sum`，以及一个记录不同元素数量的变量 `distinct_count`。
    
2. 建立第一个大小为 `k` 的窗口，计算出初始的 `sum` 和 `distinct_count`。
    
3. 检查第一个窗口是否满足 `distinct_count >= m`，如果满足，则更新全局的最大和 `max_sum`。
    
4. 开始滑动窗口，每次向右移动一格。在每一步：
    
    - 更新 `current_sum`（减去离开的，加上进入的）。
        
    - 利用频率表更新 `distinct_count`。
        
    - 检查更新后的 `distinct_count` 是否依然满足 `_count >= m`。
        
    - 如果满足，就用当前的 `current_sum` 尝试更新 `max_sum`。
        
5. 窗口滑动到数组末尾后，`max_sum` 中存储的就是最终答案。
下面是代码的具体实现：
![[Pasted image 20250911104555.png]]
![[Pasted image 20250911104633.png]]
### 知识点：
滑动窗口、数组 