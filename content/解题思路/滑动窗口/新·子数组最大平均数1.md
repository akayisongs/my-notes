![[Pasted image 20250903082202.png]]
## 思路：
这道题类似于上面一道题的方法，是一道典型的滑动窗口的题目，==最直接的想法是什么？==最直接的想法就是暴力求解：找出所有长度为k的连续子数组，逐个计算它们的和，然后再求平均数，最后比较出最大的那个。例如，对于数组[1, 12, -5, -6]和k=4，我先算[1, 12, -5, -6]的和，然后算[12, -5, -6, 50]的和，以此类推。这个方法虽然可行，但效率如何？假设数组长度为n，那么大约有n-k+1个子数组，而计算每个子数组的和都需要k-1次加法。这样总的时间复杂度大约是O(nk)，当n和k很大时，这显然不是最优解。==那么如何优化这个求和的过程呢？==我注意到，当窗口从[nums[i], ..., nums[i+k-1]]滑动到[nums[i+1], ..., nums[i+k]]时，两个子数组有大量的重叠部分。我完全没必要重新计算新窗口里所有k个元素的和。实际上，新窗口的和，就等于旧窗口的和，减去那个刚刚离开窗口的元素nums[i]，再加上新进入窗口的元素nums[i+k]。通过这种方式，我每次移动窗口，只需要一次减法和一次加法，就能在O(1)的时间内更新窗口的和。==这个优化的滑动窗口算法具体该如何实现？==实现起来应该分两步走。首先，我需要一个“启动”阶段：计算出第一个窗口（即数组的前k个元素）的和，并将其作为当前的最大和。然后，进入一个循环，让窗口开始滑动。循环从第k个元素开始，一直到数组的末尾。在每次循环中，我利用新和 = 旧和 - 离开的元素 + 进入的元素这个公式来更新窗口的和。每更新一次，我就将这个新的和与我记录的最大和进行比较，保留较大者。整个过程只需要对数组进行一次完整的遍历，所以时间复杂度被成功地优化到了O(n)。==最终结果是要求平均数，这会有什么影响？==题目要求的是最大平均数。既然所有子数组的长度都是固定的k，那么哪个子数组的和最大，它的平均数也就最大。因此，我可以全程只计算和比较“和”，直到最后一步，再用找到的最大和除以k，得到最终的最大平均数。这样可以避免在循环中进行不必要的浮点数除法运算，既能提高效率，也能保持精度。==在C语言中实现时，需要注意什么？==在C语言中，求和的结果可能会很大，所以最好使用long long类型的变量来存储sum，防止整数溢出。同时，最终的结果是浮点数，所以在计算平均值时，必须将sum或k至少一个强制转换为double类型，以确保得到的是浮点数除法的结果，而不是整数除法。
## 细节：
- 如何优化计算过程，避免重复计算？
	优化的关键在于**复用前一步的计算结果**。当我们将关注的子数组（“窗口”）向右移动一格时，实际上只有两个元素发生了变化：
	- 一个元素**离开**了窗口（最左边的元素）。
	- 一个元素**进入**了窗口（最右边的新元素）。
	因此，新窗口的和可以通过 `新和 = 旧和 - 离开的元素 + 进入的元素` 这个公式，在常数时间`O(1)`内计算出来，完全避免了重新对`k`个元素求和。
## 步骤：
#### 1. 初始化状态并计算初始和
- **创建求和变量**：创建两个变量，`current_sum`（用于记录当前窗口内元素的和）和 `max_sum`（用于记录已发现的最大和）。为防止整数溢出，建议使用长整型（`long long`）。
- **处理第一个窗口**：遍历数组的前 `k` 个元素，将它们的和累加到 `current_sum` 中。
- **设置初始结果**：将 `max_sum` 的值设为 `current_sum` 的初始值。这一步相当于计算出了第一个子数组的和，并将其作为后续比较的基准。
#### 2. 从第 k 个索引开始向右滑动窗口
- **对于每个后续位置 i (从 k 到数组末尾)**:
    - **计算 `current_sum`** = `上一步的 current_sum` - `离开窗口的元素(nums[i-k])` + `新进入窗口的元素(nums[i])`。
    - **更新后的 `current_sum`** 表示窗口向右滑动一格后，新子数组内所有元素的总和。
#### 3. 在每次滑动完成后更新最大和
- 在每次循环中更新完 `current_sum` 后，将它与 `max_sum` 进行比较。
- 更新 `max_sum` 为两者中的较大值 `(max_sum = MAX(max_sum, current_sum))`。
- 此时 `max_sum` 保存的是从数组开始到当前窗口位置所发现的、长度为 `k` 的子数组中元素和的最大值。
#### 4. 处理最终结果
- 当循环遍历完所有元素后，`max_sum` 变量中即保存了最大的子数组和。
- 由于题目要求的是最大**平均数**，且所有子数组长度固定为`k`，因此最大和对应的就是最大平均数。
#### 5. 返回最终平均值
- 将得到的最大和 `max_sum` 除以 `k`，并确保执行的是浮点数除法（例如，通过将其中一个数强制类型转换为`double`），然后将此平均值作为最终结果返回。
下面是代码的具体实现：
![[Pasted image 20250903111539.png]]
## 知识点：
滑动窗口、数组