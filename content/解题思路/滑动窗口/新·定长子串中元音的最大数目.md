![[Pasted image 20250902210054.png]]
## 思路：
这道题是一道典型的滑动窗口题目，当我们第一次遇到这道题时，可能第一眼能看出来的算法就是直接逐一遍历目标串的每一个子串，但这样很显然它的时间复杂度会达到==O（nk）==的水平，虽然这样看上去也不错了，==但是我们能不能寻求提升，将其降低到更低的水平呢==？显然，让我们时间复杂度达到==O（nk）==水平的关键便是找到它每个子串的操作，这个操作直接导致了我们需要每一次再遍历它的每个子串，既然这样，==如何才能避免每一次取出其子串后对其子串进行遍历这样的操作呢？我们是不是可以用计数器模拟遍历了这样的每个子串呢？==我记得好像是在学栈还是队列数据结构的时候就接触过使用计数器来模拟队列这样的行为，那么在这道题上具体如何做到这样的效果呢？可以想象一个密封的盒子中按照顺序放置了n个小球，要想知道其中连续k个小球颜色都是白色的最大个数是多大，我们可以使用一个只能装下k个小球的盒子，先拿出两个球，记录其中白色球的个数，由于这个盒子中白球个数已经确定，我们只需要管每次进入盒子的球以及出盒子的球是不是白色即可，所以我们进行以下的循环：将一个球拿进盒子，如果是白球则计数器加一，然后更新最多的白球数，移出最开头的球判断其是否为白球，并更新白球个数，需要注意的是更新最多白球数之前需要判断该盒子是否为装满状态，比如在最开始的时候需要先装满再进行判断，但是还需要注意的便是白球个数还是需要更新的，只是不更新最多白球个数而已，==那么还有没有什么可以优化的地方呢？==仔细观察其中的步骤我们会发现其实最大“白球个数”最大值便是“盒子”的长度，所以我们还可以在更新完最大白球个数后对代码进行剪枝。
## 细节：
- **为什么要在要在更新最长元音子串前判断子串长度是否为题给长度？**
   因为在将子串窗口填满前判断最多元音个数没有意义，因为很可能会更长
- **滑动窗口算法时间复杂度为多少呢？**
   为遍历一次原字符串的O（n），稍低于暴力遍历算法
## 步骤：
#### 1. 初始化状态计数器
- **创建计数器**：创建两个整型变量，`current_vowels`（当前窗口内的元音数）和 `max_vowels`（已发现的最大元音数）。
- **处理第一个窗口**：遍历字符串的前 `k` 个字符，统计其中元音的数量，并用这个值初始化 `current_vowels`。
- **设置初始结果**：将 `max_vowels` 的值也设为 `current_vowels` 的初始值。这一步相当于计算出了第一个子串的结果，并将其作为后续比较的基准。
#### 2. 从第 k 个索引开始向右滑动窗口
- **对于当前行的每个位置 i (从 k 到字符串末尾)**:
    - **计算 `current_vowels`** = `上一步的 current_vowels` - `(离开窗口的字符是否为元音)` + `(新进入窗口的字符是否为元音)`。
    - **更新后的 `current_vowels`** 表示窗口滑动一格后，新子串内的元音总数。
#### 3. 在每次滑动完成后更新最大值
- 在每次循环中更新完 `current_vowels` 后，将它与 `max_vowels` 进行比较。
- 更新 `max_vowels` 为两者中的较大值 `(max_vowels = MAX(max_vowels, current_vowels))`。
- 此时 `max_vowels` 保存的是从字符串开始到当前窗口位置所发现的、长度为 `k` 的子串中元音数目的最大值。
#### 4. 处理剪枝（提前终止）
- 在更新 `max_vowels` 后，检查其值是否等于 `k`。
- 如果 `max_vowels` 等于 `k`，说明已经找到了一个全由元音组成的子串，这已是理论上的最大值，因此无需继续滑动，可以直接返回 `k`。
#### 5. 返回最终结果
- 当循环遍历完所有字符，或因剪枝优化提前结束后，直接返回 `max_vowels` 作为最终结果。
下面是代码的具体实现：
![[Pasted image 20250903081547.png]]
## 知识点：
滑动窗口、字符串