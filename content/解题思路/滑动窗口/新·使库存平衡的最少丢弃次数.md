![[Pasted image 20251011162255.png]]
### 思路：
这道题同之前做的滑动窗口的题目一样都有显著的特征：**对一个数据集中不断移动的固定大小的子数据集进行判断操作**，但是刚开始拿到这道题的时候会发现，如果直接用曾经滑动窗口的方式，只是通过总和等方式来维护这个窗口，明显不能达到我们的目的了，**那么对于这道题我们应该如何独特的来设计呢？** 首先我们需要明确我们的需求，**我们如何知道第`i`天前面`w`天同类型的货物有多少呢？** 很朴素的一个想法便是维护一个二维数组来记录每种货物在该窗口内时出现的次数，这个思想其实也很好理解，就是从最开始滑动窗口基础题目的维护一个变量转变到维护一个二维数组来体现这个滑动窗口；
**那么，当窗口从第 i 天滑动到第 i+1 天时，这个“窗口内的物品计数”发生了什么变化？**
其实变化很简单，只涉及两件事：一个最老的元素（第 i-w 天的）离开了窗口，一个最新的元素（第 i 天的）尝试进入窗口。处理新进入的元素比较直接：我看一眼今天到货的物品类型 T，查一下我的计数器里 T 的数量，如果小于 m，我就保留它，并把计数器的值加一；否则就丢弃。但关键在于处理离开的元素。**我怎么知道第 i-w 天那个物品，当初到底是被我保留了还是丢弃了？**
这是一个核心障碍。如果当初它被丢弃了，那它根本就不在我的计数器里，现在它离开窗口，我的计数器也无需变化。但如果当初它被保留了，我就必须在计数器里把对应类型的数量减一，以“腾出”位置。为了区分这两种情况，我必须得记录下我过去每一天的决策。所以，我需要一个额外的辅助数组，比如叫 was_kept，was_kept[k] 就用来标记第 k 天的物品最终是保留了还是丢弃了。

这样一来，整个流程就清晰了。我从第一天开始循环到最后一天。在每一天 i，我执行两步操作：第一，检查是否需要“移除”旧物品。如果 i >= w，说明窗口已经满了，我就回头看 i-w 天的决策，查询 was_kept[i-w]。如果那天是保留的，我就在我的计数器里，把 arrivals[i-w] 对应类型的数量减一。第二，处理“加入”新物品。我查看今天 arrivals[i] 的类型，在计数器里查它的当前数量。根据这个数量和 m 的比较结果，来决定是保留还是丢弃。如果保留，我就把计数器里它的数量加一，并在 was_kept[i] 上做好“已保留”的标记；如果丢弃，就只增加我的丢弃总数。这个方法每次只对窗口的边界进行操作，避免了对整个窗口的扫描，效率很高。
### 细节：
- **在每一天，我们做出“保留”还是“丢弃”决策的依据到底是什么？**
    决策依据是一个简单的**贪心策略**。在第 `i` 天，对于新到货的物品（类型为 `T`），我们的决策完全取决于**在做出决策的这一瞬间，当前滑动窗口 `[i-w+1, i]` 内已经存在的、被我们保留下来的 `T` 类型物品数量**。
- **如果采用“计数器”法，为什么必须额外记录历史决策（即`was_kept`数组）？**
    我们的计数器只反映了当前窗口内**各种物品的总量**，但它丢失了**个体信息**——即这个总量是由哪些天的物品构成的。当窗口从 `[i-w, i-1]` 滑动到 `[i-w+1, i]` 时，第 `i-w` 天的物品离开了窗口。此时，我们必须在计数器中做出相应调整。但问题是，我们不知道第 `i-w` 天的那个物品当初有没有被我们计入计数器。
### 步骤：
- **初始化**：
    
    - 一个频率计数器 `counts` (哈希表或数组)。
        
    - 一个记录决策的数组 `was_kept`，长度和 `arrivals` 一样，初始为0。
        
    - 丢弃计数 `discarded_count = 0`。
        
- **遍历每一天 `i` (从0到n-1)**：
    
    - **步骤A：处理离开窗口的旧物品**
        
        - 如果 `i >= w`，说明窗口已经形成，有物品要离开。
            
        - 我们要看的是第 `i-w` 天的决策。
            
        - 如果 `was_kept[i-w] == 1`（那天我们保留了物品），那么我们就需要更新计数器：`counts[arrivals[i-w]]--`。
            
    - **步骤B：处理尝试进入窗口的新物品**
        
        - 获取今天到货的类型 `T = arrivals[i]`。
            
        - 检查当前 `counts[T]` 是否小于 `m`。
            
        - 如果 `counts[T] < m`：
            
            - 决策：保留。
                
            - 更新决策记录：`was_kept[i] = 1`。
                
            - 更新计数器：`counts[T]++`。
                
        - 否则 (`counts[T] >= m`)：
            
            - 决策：丢弃。
                
            - 更新丢弃总数：`discarded_count++`。
                
            - `was_kept[i]` 保持0，`counts` 不变。
                
- **返回 `discarded_count`**。
下面是代码的具体实现：
![[Pasted image 20251013135125.png]]
![[Pasted image 20251013135250.png]]
### 知识点：
数组、哈希表、贪心、滑动窗口