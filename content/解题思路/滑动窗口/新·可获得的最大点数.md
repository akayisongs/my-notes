![[Pasted image 20251010231451.png]]
### 思路：
对于这道题，我们很容易便可以看出这是一道滑动窗口类型的题目，**为什么呢？** 比较特定的元素如：一个数组，取固定长度个数字，讨论这些数字的特性如和最大或者平均数最大等，但是我们知道，滑动窗口的经典题目**本应该是取连续的数字**，但是这道题却既可以从一个数组的后面开始取数，也可以从数组的首段开始取数，**那么我们如何处理，将其和普通的滑动窗口题目联系上呢？**
既然我们总共要拿 `k` 张牌，这些牌要么来自左边，要么来自右边。我们可以想象把数组的尾部和头部连接起来，形成一个环。具体来说，就是将数组末尾的 `k` 个元素和数组开头的 `k` 个元素拼成一个新的、长度为 `2k` 的“关注区域”。我们最终拿到的 `k` 张牌，一定是这个关注区域里的一个长度为 `k` 的连续子数组。
例如，`cardPoints = [1,2,3,4,5,6,1]`, `k = 3`。我们关注的区域就是末尾的3个 `[5,6,1]` 和开头的3个 `[1,2,3]`。我们拿牌的所有组合（比如左边2个右边1个，即`[1,2,1]`）都可以在 `[5,6,1,1,2,3]` 这个拼接的逻辑数组中，找到一个长度为3的连续子数组与之对应。
因此，问题就转化为了：**在一个固定的窗口（大小为k）中，不断向一个方向滑动，找到窗口内元素和的最大值。** 接下来我们便可以用常规的滑动窗口类型题目的解决方法来完成了。
### 细节：
- **这道题要求从数组的两头取牌，形成的总和并非来自一个连续子数组，为什么还能用滑动窗口来解决？**
    这是一个核心的思维转换。我们应用的“滑动窗口”**不是**在原始数组 `cardPoints` 上寻找一个连续的子数组，而是**将“我们手中持有的 k 张牌”这个集合看作一个抽象的窗口**。
- **“环形数组”的思想在这里是如何体现的？它和滑动窗口是什么关系？**
    “环形数组”是一个绝佳的心理模型，它能让这个抽象的滑动窗口变得非常直观。你可以想象把数组 `cardPoints` 的尾部和头部“粘合”起来。更具体地说，我们只关心两端的各 `k` 个元素。我们可以把数组末尾的 `k` 个元素 `[cardPoints[n-k], ..., cardPoints[n-1]]` 拿出来，放到数组开头的 `k` 个元素 `[cardPoints[0], ..., cardPoints[k-1]]` 的前面，形成一个逻辑上的、长度为 `2k` 的新序列。在这个逻辑序列上，我们所有可能的取牌组合（例如，取左边 `i` 张，右边 `k-i` 张）都神奇地变成了这个新序列中的一个**长度为 k 的连续子数组**。
### 步骤：
**1. 初始化变量与总和**

- 计算需要保留的子数组长度，即滑动窗口的大小：`window_size = cardPointsSize - k`。
    
- 初始化一个 `long long` 类型的变量 `total_sum`，并遍历整个数组一次，计算出所有卡牌的总和。
    
- 初始化一个 `long long` 类型的变量 `window_sum`，用于存储当前窗口内元素的和。计算第一个窗口（即从索引 `0` 到 `window_size - 1`）的和。
    
- 初始化一个 `long long` 类型的变量 `min_sum`，用于记录滑动过程中遇到的最小窗口和，其初始值就设为第一个 `window_sum`。
    

**2. 滑动窗口寻找最小和**

- 使用一个 `for` 循环来模拟窗口的滑动，循环从 `window_size` 遍历到数组的末尾。
    
- 在每次循环中，高效地更新 `window_sum`：
    
    - `window_sum = window_sum + cardPoints[i] - cardPoints[i - window_size]`
        
    - 此操作代表窗口向右移动一格：加入右侧的新元素 `cardPoints[i]`，同时移除左侧的旧元素 `cardPoints[i - window_size]`。
        
- 在每次更新 `window_sum` 后，立即将其与 `min_sum` 进行比较，并更新 `min_sum` 为两者中的较小值，以确保 `min_sum` 始终是历史最小和。
    

**3. 计算最终结果**

- 当循环结束后，`min_sum` 中存储的就是所有长度为 `n-k` 的连续子数组中的最小和。
    
- 根据第一步中转换的公式，计算最终的最大点数：`result = total_sum - min_sum`。
    
- 返回 `result`。
    

**4. 处理边界情况**
- **`k` 等于数组长度**：如果 `k == cardPointsSize`，意味着必须拿走所有卡牌。此时应直接返回 `total_sum`，可以作为程序开头的特例判断。
    
- **数据溢出**：由于点数和可能很大，所有用于求和的变量（`total_sum`, `window_sum`, `min_sum`）都应使用 `long long` 类型，以防止计算过程中发生整数溢出。
![[Pasted image 20251011110028.png]]
### 知识点：
滑动窗口、数组
