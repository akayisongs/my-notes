![[Pasted image 20251013143753.png]]
### 思路：
看到这道题的第一瞬间，我便发现这道同样是滑动窗口的题目相较于之前遇到的题目，**特征没有那么明显了，并且要注意的限制条件似乎还不少**。**那么这道题目到底希望我们完成怎样的操作呢？** 为了方便我理解，我使用了一根时间轴来显示各元素的关系，很快我便发现，时间轴上有一个不断向后移动的`窗口`：就是我们需要移动`k`个会议，而题目要求是我们最多移动`k`个会议的时间，使活动中有最大的空余时间。**但是我们应该如何理解，或者说如何将最多移动k个会议实现连续空余时间最多这个条件转化为逻辑语言呢？**
题目中有两类会议：n 个时间固定的会议和 k 个时间可变的会议。固定的会议我们动不了，它们已经占据了时间轴上的一些位置。可变的会议虽然可以移动，但它们的相对顺序是不能改变的，并且自身的持续时间也是固定的。我们可以把这 k 个会议看作一个整体的“会议串”，这个“会议串”的总时长是固定的。我们可以将这个“会议串”插入到由固定会议产生的某一个空隙里，或者放在所有固定会议的最前面或最后面。为了实现所有会议“紧密排列”这个目标，我们其实并不需要真的去模拟移动过程。**那么，这个问题的本质究竟是什么？** 我意识到，无论这些会议如何排列，它们占用的总时间是一个恒定量。每个固定会议的时长是 endTime[i] - startTime[i]，每个可变会议的时长也是已知的。把所有这些会议的时长加起来，就得到了总的“繁忙时间”。而整个活动的总时长是 eventTime。总时长是固定的，总繁忙时间也是固定的。那么，总的空闲时间自然也是固定的，它等于 eventTime - 总繁忙时间。
现在问题就清晰了。**既然总空闲时间是固定的，我要如何操作才能让“最长的空闲段”最大化呢？** 答案已经呼之欲出了：就是把全部的空闲时间都集中到一段里。正如最开始的猜想，只要我们把所有会议（无论是固定的还是可变的）都想象成可以挤在一起的积木块，将它们全部推到时间轴的一端，那么另一端剩下的就是一整个连续的、完整的空闲时间。这个空闲时间的长度就是总空闲时间。因此，这道题的解法就简化成了一道计算题：计算出所有 n 个固定会议和 k 个可变会议的总时长，然后用 eventTime 减去这个总时长，得到的结果就是我们能获得的最大空闲时间。这个思路避开了复杂的区间调度和插入模拟，直指问题的核心，将一个看似困难的优化问题转化为了简单的算术问题。
### 细节：
- **移动一个或多个会议，到底能带来什么效果？**
    由于“相对顺序不变”的限制，我们不能随意地将一个会议从时间轴的一端挪到另一端。 想象一下时间轴上排列着 会议 - 空闲 - 会议 - 空闲 ... 这样的序列。当我们选择移动一个会议 M_i 时，如果它相邻的会议 M_{i-1} 和 M_{i+1} 都是固定的，那么 M_i 只能在 M_{i-1} 结束后和 M_{i+1} 开始前这段空间里滑动。这样做可以把 M_i前后的两段空闲时间合并成一整段。
- **如何将原问题转化为一个我们熟悉的模型？**
    基于上一个问题的结论，原问题“选择最多 `k` 个会议来移动以最大化最长空闲时间”，就可以转化为： **“在所有空闲时间段组成的序列中，找到一个长度不超过 `k+1` 的连续子序列，使其总和最大。”** 这里的逻辑是：移动 `m` 个会议（`m <= k`）可以合并 `m+1` 个空闲段（`m+1 <= k+1`）。我们想让合并后的空闲段最大，就是要找到那个和最大的、长度不超过 `k+1` 的连续空闲段子序列。
### 步骤：
- **定义数据结构和函数签名**
    
    - 首先，包含必要的头文件：`stdio.h` (输入输出), `stdlib.h` (内存分配和 `qsort`), `string.h` (内存操作)。
        
    - 为了方便对会议进行排序，定义一个结构体来捆绑每个会议的开始和结束时间。
        
    - 定义你的主函数签名，它会接收题目给出的所有参数。
        
    - 使用 `long long` 作为返回值和中间计算变量的类型，以防止因时间总和过大而导致的整数溢出。
        
- **处理边界情况**
    
    - 在函数开头，先处理最简单的边界情况。如果没有任何会议 (`n == 0`)，那么整个活动时间都是空闲的。
        
- **数据整合与排序**
    
    - 将 `startTime` 和 `endTime` 两个数组的数据整合到我们定义的 `Meeting` 结构体数组中。
        
    - 为了能正确计算会议之间的间隙，必须保证会议是按开始时间排序的。编写一个比较函数，并使用 `qsort` 对 `meetings` 数组进行排序。
        
- **计算所有基础空闲时段 (Gaps)**
    
    - 创建一个数组 `gaps` 来存储所有基础的、连续的空闲时段的长度。这个数组的大小将是 `n + 1`。
        
    - 填充这个数组：
        
        - 计算初始空闲：`gaps[0] = meetings[0].start;`
            
        - 循环计算会议之间的空闲：`for (int i = 1; i < n; i++) { gaps[i] = meetings[i].start - meetings[i-1].end; }`
            
        - 计算最终空闲：`gaps[n] = eventTime - meetings[n-1].end;`
            
- **计算所有会议自身的时长**
    
    - 当我们将一组会议“挤”在一起时，它们本身占用的时间也会被释放出来，加入到总的空闲时间里。因此，需要一个数组来存储每个会议的持续时间。
        
- **核心算法：滑动窗口**
    
    - 这是解决问题的核心。我们的目标是找到一个窗口，其包含的 `m` 个会议（`m <= k`）和 `m+1` 个间隙的总时长最大。
        
    - 初始化变量：
        
    - **首先，任何一个独立的 `gap` 本身就是一个合法的空闲时间，所以先用它们初始化最大值。**
        
    - **然后，使用滑动窗口计算合并后的空闲时间。** 窗口在 `gaps` 数组上滑动，大小不超过 `k+1`。
        
- **清理内存并返回结果**
    
    - 释放所有动态分配的内存，避免内存泄漏。
        
    - 返回计算出的最大空闲时间。
下面是代码的具体实现：
![[Pasted image 20251014111712.png]]
### 知识点：
滑动窗口、贪心