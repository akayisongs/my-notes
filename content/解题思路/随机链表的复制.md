![[Pasted image 20250611234015.png]]
### 思路：
这道题在解决带有随机指针的链表深拷贝问题，我们需要创建一个与原链表结构完全相同但完全独立的新链表，其中每个新节点不仅要正确复制值，还要精确复现原节点间的next顺序关系以及random随机指向关系。这个看似复杂的任务，实际上可以通过一种巧妙的三步法高效完成，先***为每个节点创造"影子"，再让影子学会模仿原身的随机行为，最后将影子从本体中分离出来形成独立个体***。
当我们面对原链表时，首先遇到的挑战是：**如何在不使用额外空间的情况下建立新旧节点的对应关系**？答案就在链表结构本身。第一步，我们遍历原链表，为每个节点创造完美的复制品：在A节点后插入A'，B节点后插入B'，形成A->A'->B->B'->C->C'的链式结构。这个操作的精妙之处在于，复制节点如同原节点的"贴身影子"，通过物理位置的直接相邻建立了天然映射关系。当我们创建A'时，不仅复制了A的值，更将A'插入到A与B之间，这样A'的next自然指向B，而A的next则重定向到A'，既保留了链表连续性，又为后续操作奠定基础。
**那么如何让复制节点准确复现原节点的随机指针指向**？由于第一步已让每个复制节点紧邻原节点，我们可以利用这个位置关系解决。假设原节点A的random指向C，那么A'的random应该指向C的复制节点C'。**而C'的位置在哪里**？就在C的后面，因此，我们只需通过A->random->next就能直达C'。这个过程如同教影子学习原身的动作：当原身指向某个目标时，影子只需指向目标对象的影子即可。遍历整个链表时，对每个原节点，我们通过cur->next找到其复制节点，再通过cur->random->next设置其随机指针，若遇到random为空的情况，则复制节点的random同样置空，确保行为完全同步。
第三步的任务就是将两个链解开。**那么如何将两条链解开呢**？我们启动两个指针：cur负责恢复原链表，copyCur负责构建复制链表。cur从A出发，将A的next从A'改为B（即A->next->next），就像剪断连接A与A'的线；同时copyCur指向A'，将A'的next指向B'（即A->next->next->next），随后cur移动到B，copyCur移动到B'，重复相同操作。每次操作都剪断原节点与复制节点的连接，同时建立复制节点间的连接，最终原链表恢复为A->B->C，复制链表则形成A'->B'->C'，两者完全独立却结构相同。
### 细节：
- **为什么简单遍历复制无法解决随机指针问题？**
    因为随机指针可能指向链表任意位置，当复制节点时，新节点的随机指针需要指向新链表中的对应节点而非原节点。若仅简单复制节点值并建立next关系，我们无法直接确定新节点与旧节点间的映射关系，导致随机指针无法正确设置。
- **这种方法有何优势？**
    三步法完美避开了哈希表的空间开销，时间复杂度保持O(n)（三次线性扫描），空间复杂度仅O(1)（额外指针）。更重要的是，它保持原链表结构不变，同时构建出完全独立的深拷贝链表。每个复制节点都通过malloc全新创建，随机指针正确指向新链表节点，完全满足深拷贝要求。
### 步骤：
1. 遍历原链表，为每个节点创建对应的复制节点，并将复制节点插入到原节点之后，形成交替连接的结构，这样原节点A后接复制节点A'，依此类推，建立起新旧节点间的直接对应关系；
2. 再次遍历链表，处理随机指针的复制：对于每个原节点的random指针，若其非空，则将其指向节点的下一个节点（即对应的复制节点）赋给当前复制节点的random指针，确保新链表中随机指针的正确指向；
3. 进行链表拆分操作，使用两个指针分别跟踪原链表和复制链表，通过调整next指针将两者分离，恢复原链表结构的同时构建出完整的复制链表。
下面是代码的具体实现：
![[Pasted image 20250612000425.png]]
### 知识点：
链表
