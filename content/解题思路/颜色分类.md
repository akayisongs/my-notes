![[Pasted image 20250614214656.png]]
### 思路：
这道题要解决对由0（红色）、1（白色）和2（蓝色）组成的数组进行原地排序，使相同颜色元素相邻，并严格遵循红-白-蓝的顺序排列。那么**如何高效实现这一目标呢**？核心在于三指针分区算法：使用`low`指针标记红色区域的边界，`high`指针标记蓝色区域的边界，`current`指针遍历未处理元素。**具体操作逻辑是怎样的呢**？当`current`遇到0时，将其与`low`位置交换并同时移动两个指针，这确保红色元素归位；当遇到2时，与`high`位置交换但保持`current`不动，以便检查交换来的新元素；遇到1时则直接推进`current`。**为什么处理2时不移动current呢**？因为从数组末尾交换来的元素可能是0或2，需要重新检查，否则可能遗漏关键元素。例如数组[2,0,1]若错误移动：交换首尾得[1,0,2]后若移动`current`，会跳过0导致排序错误。**算法如何保证效率呢**？通过三个指针协同工作，每个元素最多被访问两次（0和1通常一次，2可能两次），使时间复杂度严格控制在O(n)，而仅用三个变量的设计满足O(1)空间复杂度要求。
### 细节：
- **算法如何保证正确性？**
    数学上可证明三个不变式：low左侧永远全为0，high右侧永远全为2，current左侧到low之间全为1 ，每次操作都维护这些不变式，而待处理区域随current和high逼近逐渐缩小。当current>high时，待处理区消失，排序完成。
### 步骤：
1. 初始化三个指针：
    low = 0：指向红色区域（0）的末尾，初始位置0
    current = 0：遍历指针，处理当前元素
    high = 数组长度-1：指向蓝色区域（2）的开头
2. 当 current ≤ high 时，
    情况1：当前元素为0（红色）
    交换 nums[current] 和 nums[low]
    low 指针右移：low++
    current 指针右移：current++
    情况2：当前元素为1（白色）
    保持元素位置不变
    仅 current 指针右移：current++
    情况3：当前元素为2（蓝色）
    交换 nums[current] 和 nums[high]
    high 指针左移：high--
    注意：current 指针保持不动
   3. 当 current > high 时结束循环，此时所有元素已处理完毕。
下面是代码的具体实现：
![[Pasted image 20250615003852.png]]
### 知识点：
三指针、数组
