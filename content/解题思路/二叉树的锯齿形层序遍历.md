![[Pasted image 20250707201658.png]]
### 思路：
这道题同以往的二叉树层序遍历不太相同，它的相邻层的遍历方向是交替的——第一层从左到右，第二层从右到左，第三层又回到从左到右。这让我联想到生活中上下楼梯时左右脚交替的感觉。那么关键问题就变成了：如何在保持层序遍历基本框架的前提下，实现这种方向交替？
接下来我思考：==层序遍历的核心是什么？==当然是队列这个数据结构。普通层序遍历中，我们总是按固定顺序处理节点：从左到右将子节点加入队列。但锯齿形遍历要求我们改变输出顺序，而不是改变处理顺序。这里出现一个重要认识：节点入队的顺序必须始终保持"先左后右"，否则会破坏整个遍历的层级结构。==那么方向变化应该体现在哪里呢？==显然，应该在存储结果的时候进行方向调整，而不是在节点处理过程中。==于是如何在存储结果时实现方向反转呢？==一个自然的想法是：根据当前层数的奇偶性来决定存储顺序。对于偶数层（0,2,4...）我们正序存储，对于奇数层（1,3,5...）我们逆序存储。这个想法看似简单，但实现时需要考虑一个重要细节：==逆序存储时如何确定每个节点的存放位置？==这里我想到可以通过索引计算来解决——奇数层时，将节点值存放在当前层数组的"末尾位置向前递减"的位置。比如有三个节点时，第一个节点放在索引2，第二个放索引1，第三个放索引0。想到这里，新的问题出现了：==这样实现是否会影响下一层的节点入队顺序？==经过仔细思考，我发现不会。因为无论当前层如何存储结果，我们处理子节点的顺序始终是固定的：先左子节点后右子节点。这个处理顺序保证了队列中的节点始终保持正确的层级顺序。这就像在流水线上装配产品：无论最终包装盒如何排列，装配工序本身不受影响。
在确认核心算法可行后，我开始考虑边界情况和具体实现。==空树的情况需要特殊处理吗？==当然需要，这是所有树操作的共同边界条件。==内存管理怎么办？==C语言中必须谨慎处理每个malloc和realloc，确保任何分配失败时都能正确释放已申请的资源。特别是结果数组需要动态扩展，每层都要单独分配空间，同时还要更新一个记录每层节点数的数组。这就像建造楼房时，每层都需要独立的结构支撑，同时还要有统一的施工图纸记录每层的房间数。
最后，我反思整个方案的时间空间复杂度。每个节点入队出队一次，时间复杂度O(n)是最优的。空间上队列最大宽度为O(n)，结果存储也是O(n)，整体空间复杂度合理。至此，完整的解决方案已经清晰：在标准层序遍历框架中，加入基于层数奇偶性的索引计算，实现存储时的方向控制。这个思考过程让我深刻体会到，该算法设计就像解绳结——需要找到那个关键的转折点，既保持核心结构不变，又能灵活调整输出形态。
### 细节：
- **何时进行方向反转？如何标记反转时机？**
    方向反转发生在**层与层之间**而非节点之间。我们通过**层数计数器（level）** 的奇偶性判断方向：
    - 偶数层（0,2,4...）：从左向右存储（正序）
    - 奇数层（1,3,5...）：从右向左存储（逆序）  
     例如：第0层（根节点）正序 → 第1层逆序 → 第2层正序... 这种交替模式如同织布的经纬线交错。
     **正序存储**（偶数层）：  
    直接按处理顺序存储 → `index = i`  
    示例：节点A,B,C → 存储位置[0],[1],[2] → [A,B,C]
     **逆序存储**（奇数层）：  
    通过`size-1-i`计算倒序位置 → `index = size-1-i`  
    示例：节点A,B,C → 存储位置[2],[1],[0] → [C,B,A]
### 步骤：
1. **初始化队列和数据结构**
- 创建队列数据结构用于层次遍历
- 初始化结果数组（二维指针）和列大小数组（一维指针）
- 设置层数计数器从0开始（0表示偶数层）
2. **处理根节点**
- 若根节点为空，直接返回空结果
- 将根节点加入队列，开始遍历过程
3. **层级遍历主循环**
- **while**（队列非空）：
    - 获取当前层节点数（队列大小）
    - 为当前层分配存储数组`currentLevel[size]`
4. **处理当前层节点**
- **for**（遍历当前层所有节点）：
    1. 从队列取出节点
    2. **关键步骤：方向控制存储**
        - 若当前层为偶数：`index = i`（从左到右存储）
        - 若当前层为奇数：`index = size-1-i`（从右到左存储）
    3. 将节点值存入`currentLevel[index]`
    4. 按**固定顺序**（先左后右）将子节点入队
5. **保存当前层结果**
- 将`currentLevel`加入结果数组
- 记录当前层节点数到列大小数组
- 层数计数器+1（切换奇偶状态）
6. **内存管理**
- 每层处理完后释放队列节点内存
- 检测内存分配失败情况，确保安全释放：
    - 当前层分配失败 → 释放所有已分配内存
    - 结果数组扩展失败 → 释放所有已分配内存
7. **返回结果**
- 设置返回参数：
    - `*returnSize` = 总层数
    - `*returnColumnSizes` = 每层节点数数组
- 释放队列结构内存
- 返回结果二维数组
下面是代码的具体实现：
![[Pasted image 20250707230404.png]]
### 知识点：
队列、bfs、二叉树