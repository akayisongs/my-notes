![[Pasted image 20250710194738.png]]
### 思路：
当我面对链表插入排序这个问题时，脑海中浮现的第一个疑问是：==链表没有随机访问能力，如何实现插入排序的核心操作——将元素插入到已排序序列中的指定位置？==这让我意识到需要完全重新思考插入排序在链表这种数据结构上的实现方式，而不是简单照搬数组的解法。毕竟，在数组中我们可以轻松地前后移动元素，但链表的节点移动则受限于指针关系。
顺着这个思路，我不禁自问：==能否像数组那样维护一个已排序区域和一个未排序区域？== 这个想法让我豁然开朗——完全可以将链表拆分为两部分：已排序链表和待排序链表。但新的困惑随之而来：==如何在链表中高效地找到插入位置？==我回想起数组插入排序需要从后往前扫描，但在单向链表中只能单向遍历。经过推敲，我发现从已排序链表的头部开始顺序查找是唯一可行方案，虽然最坏情况下时间复杂度是O(n²)，但链表节点数上限5000完全可接受。
接下来我思考具体实现细节：==如何避免在插入时破坏链表结构？==这个关键问题让我想到需要同时保存三个指针：当前待插入节点、它在原链表中的后继节点（避免丢失后续节点）、以及在已排序链表中查找插入位置的游标指针。这时我突然意识到：==链表头部插入是个特殊情况，怎么处理？==这促使我引入哑节点(dummy node)的巧妙设计——它作为已排序链表的永久头部，统一了在任意位置插入的操作，消除了对头部插入的特殊处理。在构思指针操作时，==如何确保插入后链表不断裂？==通过画图模拟，我总结出必须严格遵循的操作顺序：先保存当前节点的下一个节点，然后在已排序链表中找到插入位置的前驱节点，最后执行"当前节点->next = 前驱节点->next; 前驱节点->next = 当前节点"的指针重定向。这个顺序若颠倒，就会导致链表断裂。
实现过程中，我又想到边界情况：==单节点或空链表怎么处理？==这很简单——直接返回原链表即可。但更隐蔽的问题是：==如何处理重复值？==由于题目没有特殊说明，我决定保持排序稳定性，将新节点插入在相等值节点之后，这恰好符合"prev->next->val < curr->val"的循环条件。
最终我反思整个方案：==为什么这个方法比将链表转为数组排序再转回更优？==虽然时间复杂度相同，但空间复杂度O(1)完胜数组解法O(n)。更重要的是，这种原地排序保持了原始节点的内存地址，在某些系统设计中至关重要。通过这个思考过程，我不仅解决了问题，更深化了对链表操作的理解：指针的精确操控如同神经外科手术，稍有不慎就会导致"内存泄漏"或"链表断裂"。
### 细节：
- **如何正确处理节点插入操作？**
    `curr->next = prev->next;  // 步骤1：当前节点指向prev的后继`
    `prev->next = curr;        // 步骤2：prev指向当前节点`
1. 必须先保存`prev->next`，否则会丢失链表后续部分
2. 再更新`prev->next`指向新节点
3. 确保链表不断裂
- **如何处理头节点插入的特殊情况？**
   - 使用**哑节点(dummy node)** 统一处理
   - 哑节点始终位于已排序链表头部
   - 避免单独处理头节点插入的情况
   - 最终返回`dummy.next`作为真实头节点
### 步骤：
1. **初始化哑节点**
    - 创建一个哑节点(`dummy node`)作为已排序链表的头部
    - 将哑节点的`next`指针设为`NULL`
    - 初始化`curr`指针指向原始链表的头节点
2. **遍历原始链表**
    - 使用`while`循环遍历整个链表，直到`curr`为`NULL`
    - 每次迭代处理一个节点
3. **保存后继节点**
    - 在断开当前节点前，保存其下一个节点的指针：`next_temp = curr->next`
    - 防止链表断裂的关键操作
4. **查找插入位置**
    - 从哑节点开始遍历已排序链表
    - 使用指针`prev`定位插入位置的前驱节点
    - 查找条件：`while (prev->next != NULL && prev->next->val < curr->val)`
    - 找到第一个大于等于当前节点值的位置
5. **执行节点插入**
    - 将当前节点插入到`prev`之后
    - 操作顺序：  
        a. `curr->next = prev->next`（连接后续链表）  
        b. `prev->next = curr`（完成插入）
    - 严格保持此操作顺序防止链表断裂
6. **移动处理指针**
    - 将`curr`更新为之前保存的`next_temp`
    - 继续处理下一个待排序节点
7. **处理边界情况**
    - 空链表：直接返回`NULL`
    - 单节点链表：直接返回原链表
    - 所有节点值相同：使用`<`比较保证稳定排序
8. **返回排序结果**
    - 返回哑节点的`next`指针作为排序后链表的头节点
    - 哑节点的`next`始终指向排序链表的实际头节点
下面是代码的具体实现：
![[Pasted image 20250710204717.png]]
### 知识点：
链表、排序