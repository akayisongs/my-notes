![[Pasted image 20250618163102.png]]
条件：
- `m == board.length ` `n == board[i].length`，`1 <= m, n <= 12`
- `board[i][j]` 是一个小写英文字母
- `1 <= words.length <= 3 * 104`
- `1 <= words[i].length <= 10`
- `words[i]` 由小写英文字母组成
- `words` 中的所有字符串互不相同
### 思路：
这道题要求我们在二维字符网格中找到**以相邻元素构成**的单词字符串中的单词，我首先想到的是通过以各单词字符串中的首字母为起点在二维字符网格中进行类似dfs算法遍历，在这种算法思路下，=这里可以使用一个双层循环，内层循环遍历各单词字符串中单词的首字母，外层循环遍历整个二维数组中的元素，当找到相等元素时，即开始后续的类dfs算法进行遍历，**具体如何操作呢**？先遍历与该元素邻接的元素，但题目说了不能在一个单词中重复遍历一个二维字符网格中的元素两次，**如何办到呢**？可以通过一个visited数组对各元素进行标记，遍历时要判断该元素是否曾被遍历过，还要注意需要先判断向外拓展的指针是否越界，可以使用提供的二维数组长宽进行判断，之后并将其与以上面首字母开头的单词进行逐一比对，**这里是如何将上面首字母传过来的呢**？可以将后面的算法包装成一个函数，将上面首字母以下标形式传进函数，那么如果遇到相同的元素，该**如何进行下一步搜索呢**？正好上面提到的以函数形式包装起到了作用，可以考虑用递归的方法，将相同元素的下标继续进行传递，**那么这里递归的边界是什么呢**？应该是单词指针走到了该单词的末尾，也可通过提供的单词长度进行判断，这里由于发现其实每一遍都需要判断是否被遍历过，以及是否越界，干脆将两个判断放在函数里即可，然后如果某次在一个单词的便利中发现相邻元素没有匹配的元素了，即可返回，注意这种返回和将该单词遍历完成的返回是不一样的，**如何区分呢**？可以通过返回一个标记，如未找到则返回-1，找到则返回1，还有由于题目要求是每个单词在遍历的时候不能有重复元素，但没有说各单词之间也有这样的规矩，所以不管找没找到，每次需将visited数组初始化或者每次都需要释放掉该内存并重新分配一个空间来存放visited数组，如果每轮找到该单词则直接打印出来即可。
### 细节：
- **当所有单词搜索完成后，如何满足输出的字典序要求？**
    只需对结果数组进行快速排序即可。
- **对于网格中同一个首字母出现多次的情况，如何处理？**
    每次在网格中找到一个首字母，就启动一次DFS搜索。如果从其中一个位置找到了该单词，那么就可以记录并跳过后续的首字母位置（因为已经找到了）。但是，注意同一个单词可能通过不同的路径出现多次，但题目要求每个单词只需要出现一次在结果中，所以一旦找到就可以停止该单词的搜索。
### 步骤：
1. 首先创建结果数组存储找到的单词，初始化返回大小变量。检查边界情况：若网格为空或单词列表为空，直接返回空结果。
2. 对单词列表中的每个单词进行独立处理：
    - 跳过空单词（特殊情况处理）
    - 为当前单词创建访问标记数组`visited`，初始化为未访问状态
3. 在网格中扫描匹配当前单词的首字母
    - 逐行逐列遍历网格
4. 从首字母位置开始递归搜索：
- **边界检查**：确保位置在网格范围内
- **访问检查**：确认当前位置未被使用过
- **字符匹配**：验证网格字符与单词当前字符一致
- **终止条件**：当匹配到单词最后一个字符时，标记单词找到
- **四向探索**：向右/左/下/上四个方向递归搜索下一字符
- **回溯处理**：递归返回时重置访问标记
5. 若DFS找到单词：
    - 将单词加入结果集
    - 释放当前单词的`visited`数组
    - 跳出当前单词的搜索循环（因单词只需找到一次）
6. 所有单词处理完成后：使用快速排序对结果单词按字典序排列，释放辅助内存空间，返回排序后的结果数组及大小，格式化打印找到的单词，释放结果数组内存。
下面是代码的具体实现：
![[Pasted image 20250618201125.png]]
![[Pasted image 20250618201205.png]]
### 知识点：
字符数组、dfs
