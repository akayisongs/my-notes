![[Pasted image 20250705135611.png]]
### 思路：
这道题很有意思，首先浮现在脑海中的是：==这个问题的本质是什么？==它实际上是一个字符串解析与状态管理的结合体，需要根据特定规则对输入路径进行重构。那么，==最核心的问题处理是什么呢？==显然是如何高效地处理那些特殊符号，特别是单个点表示当前目录，双点表示上级目录——同时还要消除多余的斜杠。这让我联想到栈结构的特点，因为路径的层级关系天然具有先进后出的特性，当遇到".."时需要回溯到上一级目录，不正像是弹出栈顶元素的操作吗？接下来，深入推敲具体实现方案，==如何分解这个复杂的路径字符串？==考虑到路径由斜杠分隔，很自然地想到应该以斜杠为界分割字符串。但这里有个关键细节：多个连续斜杠应视为单个斜杠。因此设计扫描逻辑时，我决定用双指针技巧——start标记段落的起点，end向前扫描直到遇到斜杠或字符串结尾。这样不仅能跳过连续斜杠，还能准确提取每个路径段。然后，针对提取的每个路径段，我需要分类处理。这里出现新的问题：==如何处理各种点符号？==通过反复推敲示例，特别是示例中"/.../a/../b/c/../d/./"的情况，我明确认识到：只有单个点和双点具有特殊含义，三点及以上的点序列都应当作普通目录名。这个很关键，因为初看时容易误以为所有点序列都需要特殊处理。于是形成处理逻辑：遇到"."忽略，遇到".."则弹出栈顶目录（若栈非空），其他情况全部入栈。在构思栈结构时，我又面临设计选择：==是存储完整字符串还是存储引用？==考虑到内存效率，我选择存储每个路径段的指针和长度，而非复制子字符串。这样在最终拼接时通过memcpy高效复制即可。这个决定特别重要，因为路径长度可能达极大，避免不必要的复制能显著提升性能。当主要逻辑清晰后，我开始考虑边界情况。最特殊的莫过于根目录处理：当路径是"/../"时，弹出操作后栈应为空，此时必须返回根目录"/"。这促使我在最终判断，若栈空则直接返回"/"。另外想到路径末尾斜杠问题：规范要求不能以斜杠结尾，但我的拼接逻辑自然满足这点，因为只在目录名前加斜杠，最后一个目录名后不会添加多余斜杠。最后构建结果字符串时，我精确计算了内存需求，先遍历栈内元素计算总长度（每个元素需要1个斜杠加目录名长度），这样避免二次遍历。拼接时从根斜杠开始，依次添加每个目录段，确保目录间用单个斜杠分隔。整个过程就像搭积木，先拆解原始路径，筛选有效部件，再按规范重新组装。
经过这样层层递进的思考，从问题本质到具体实现，从核心逻辑到边界处理，最终形成完整解决方案。这种将复杂问题分解为可操作步骤的思维过程，不仅解决了当前问题，更深化了对状态管理和字符串处理的理解。
### 细节：
- **连续斜杠为何不影响核心逻辑？**
双指针设计**天然跳过冗余分隔符**：
    `end`指针扫描到非斜杠字符才记录段落；
    `start = end + 1`自动跳至下一有效字符  ；
    空段落（`part_len=0`）被分类规则忽略，符合"//=/"语义。
### 步骤：
1. **初始化数据结构**  
    创建栈结构（数组模拟）存储有效路径段：`parts`数组存放各段起始指针，`lengths`数组记录对应段长度，栈顶指针`top`初始化为-1。计算输入路径长度`len`，准备双指针扫描；
2. **跳过根斜杠启动扫描**  
    从索引1开始扫描（跳过绝对路径开头的`/`），设置`start=1`作为段起始指针，`end=1`作为段结束指针；
3. **双指针分割路径段**  
    循环执行直到`start`越界：
    - 移动`end`指针：从`start`开始向右扫描，直到遇到`/`或字符串结尾
    - 计算段长度：`part_len = end - start`
    - 当段非空时（`part_len>0`）进入分类处理；
4. **路径段分类处理**
    - **当前目录标识**：若`part_len==1`且`path[start]=='.'`，直接忽略
    - **上级目录标识**：若`part_len==2`且内容为`".."`，栈非空时弹出栈顶元素（`top--`）
    - **有效目录名**：其他情况压入栈中（`top++`，记录`parts[top]=&path[start]`和`lengths[top]=part_len`）
    - 更新`start = end + 1`跳至下一段；
        
5. **处理空栈特殊情况**  
    扫描完成后若栈空（`top == -1`），直接返回根路径：分配2字节内存，返回`"/"`
6. **预计算结果字符串长度**
    - 遍历栈内有效段：`total_len += (1 + lengths[i])`（1代表目录前的`/`）
    - 额外预留1字节存放终止符`\0`；        
7. **构建规范路径字符串**
    - 分配`total_len+1`字节内存
    - 初始化位置指针`pos=0`
    - 遍历栈元素：
        - 添加目录分隔符：`res[pos++] = '/'`
        - 复制目录名：`memcpy(res+pos, parts[i], lengths[i])`
        - 更新位置：`pos += lengths[i]`
    - 末尾添加终止符：`res[pos] = '\0'`
8. **返回简化路径**  
    最终返回构建的字符串指针。
下面是代码的具体实现：
![[Pasted image 20250706021311.png]]
### 知识点：
栈、字符串

