![[Pasted image 20250621142030.png]]
### 思路：
这道题既然题目明确给出数组已按非递减顺序排列，这个**有序特性**就是解题的关键。那么**有序性意味着什么**？它意味着我们可以像查字典一样高效地定位元素，不必像无序数组那样盲目搜索。因此我首先想到双指针法，让左指针从数组头出发，右指针从尾部开始，通过比较当前和与目标值的大小关系，智能地调整指针位置，**具体如何实现呢**？我们可以计算左右指针当前指向值的和，若等于目标值立即返回；若小于目标值，说明需要更大的数，就将左指针右移（因为右边数更大）；若大于目标值，则需更小的数，将右指针左移（左边数更小），**这个方法会有漏解吗**？因为数组有序性保证了移动方向的确定性，当和小了，左指针左侧的所有数（比当前更小）与当前右指针组合都不可能满足条件，可直接排除；反之亦然，因此每次移动都排除了一批无效组合，不会漏解，**但是具体如何移动左右指针呢**？如果是按序依次移动有点浪费有序这个条件了，这时我们就想到另一个移动技巧：**二分查找**。**为何使用二分查找会更好呢**？如果目标值与当前和差距很大，指针需要单步移动很多次。比如在[1,2,3,...,10000]中找5000+5001=10001，右指针需要移动近5000次，这时利用二分查找良好的跳跃能力效率便会高上不少，**具体如何高效利用二分查找呢**？关键在于设定智能触发条件，我决定当当前和与目标值差距超过当前指针值的一半时才启用二分查找——这个阈值确保只在收益明显时使用。比如左指针在1，右指针在1000，目标和是2000，此时和1001远小于目标值，差距999远大于右指针值1000的一半，就触发二分查找：在左指针右侧区域寻找最大的满足numbers[left]+numbers[mid]<target的mid位置，直接将左指针跳到新位置，神奇的是，这种融合不会增加时间复杂度，最坏仍是O(n)，但平均性能大幅提升，那么最后**如何处理边界情况和重复元素呢**？首先，二分查找范围始终控制在(left, right)内，避免越界；其次，当二分查找找不到更优位置时（如newLeft未更新），自动回退到标准单步移动。对于重复元素，由于我们寻找的是特定和而非特定值，二分查找会自然定位到满足条件的边界位置，重复元素不会造成干扰。最后记得下标从1开始的细节，在返回前统一+1即可。
### 细节：
- **使用二分查找后会不会导致错过正确解呢？**
    二分查找的设计保证了跳跃的安全性：在左指针优化时，我们寻找的是"最大满足numbers[left]+numbers[mid]<target"的位置，意味着新位置的下一个元素就会使和超过目标值，因此我们跳过的区域都是确定无效的，即使触发二分查找，最后仍需验证新位置的和，双重保障确保万无一失。
### 步骤：
1. 设置左指针 left = 0（数组起始位置），右指针 right = numbersSize - 1（数组末尾位置）；
2. 当 left < right 时持续执行以下操作：计算当前双指针值的和：sum = numbers[left] + numbers[right]，若 sum == target：将指针下标转换为1-based索引（left+1, right+1），立即返回结果数组 [index1, index2]，若 sum < target：判断是否启用二分优化：当 (target - sum) > numbers[right] / 2 时，在区间 [left+1, right] 执行二分查找，寻找最大的满足 numbers[left] + numbers[mid] < target 的 mid，将左指针直接跳到 mid 位置，否则左指针单步右移 left++；若 sum > target时类似；
3. 返回前确保将0索引转换为1索引，释放分配的内存。
下面是代码的具体实现：
![[Pasted image 20250621150125.png]]
### 知识点：
双指针、数组、二分查找