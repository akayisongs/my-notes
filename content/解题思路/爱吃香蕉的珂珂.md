![[Pasted image 20250607225633.png]]
### 思路：
这道题关键是要找到给定时间内最小吃香蕉速度，当速度k较小时，吃完所有香蕉需要的时间较长；随着k增大，所需时间会减少。但若k过大，虽能及时吃完却不符合"最小速度"的要求，那么，如何确定k的合理范围呢？显然，k的最小值至少为1，因为珂珂每小时至少吃一根香蕉。而k的最大值应是香蕉堆中的最大堆值，因为当k等于最大堆时，珂珂每小时能吃完任意一堆，这是确保能在有限时间内吃完的最保守速度。接下来，如何高效搜索这个范围？考虑到k的整数特性及范围的有序性，二分查找成为理想选择。二分查找的核心在于如何判断中间值mid的可行性。这需要设计一个时间计算函数：对于每堆香蕉p根，以速度k吃完需要ceil(p/k)小时，其中ceil表示向上取整。巧妙的是，这可通过(p + k - 1)/k实现整数运算。将所有堆的时间累加，就得到总耗时。在二分过程中，当mid速度所需时间不超过h时，说明速度足够快，此时应尝试缩小k值，故将右边界移到mid。反之，若时间超过h，则必须增大k值，故将左边界移到mid+1。这个过程如同精心校准的天平：左边界代表速度不足，右边界代表速度足够，通过不断调整使两者逼近临界点。最终，当左边界与右边界重合时，便找到了最小可行速度。这个结果具有严谨性：因为循环结束时左边界指向第一个满足条件的k值，所有更小的速度都验证过会导致超时。整个过程如同抽丝剥茧，通过有序排除不可能的速度区间。

### 步骤：
1. 初始化最小速度left = 1
2. 找出香蕉堆中的最大值max_pile，遍历所有香蕉堆，记录遇到的最大值
3. 设置最大速度right = max_pile
4. 实现时间计算函数，计算逻辑：初始化总时间totalHours = 0，遍历每堆香蕉：使用向上取整公式：(piles[i] + k - 1) / k，累加到totalHours，返回总时间
5. 执行二分查找，当循环结束时，left即为最小满足条件的k值，返回left
具体代码实现如下：
![[Pasted image 20250607235729.png]]
### 知识点：
二分查找、数组