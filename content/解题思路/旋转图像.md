![[Pasted image 20250623214542.png]]
### 思路：
当我初次看到题目要求将矩阵原地旋转90度时，脑海里立即跳出几个关键问题：==旋转后每个元素究竟会落在哪里？如何避免覆盖原始数据？怎样才能用最小代价完成这种空间约束下的变换？ ==这些疑问构成了探索的起点。
首先，我尝试用具体例子观察规律。盯着示例中的数字1：它原本在(0,0)位置，旋转后跑到了(0,2)。接着追踪数字2：从(0,1)移动到(1,2)，数字3从(0,2)转移到(2,2)。继续验证发现，数字7从(2,0)神奇地出现在(0,0)。这些轨迹逐渐揭示出隐藏的数学关系——对于任意元素(i,j)，新位置必然是(j, n-1-i)。这个发现让我振奋，因为它意味着旋转本质上是坐标的精确映射。
然而，喜悦很快被新问题冲淡：如果直接根据映射关系交换元素，先移动的元素会覆盖未处理的原始数据。比如把(0,0)的1移到(0,2)时，会抹掉该位置的3。这就像拼图时强行拖动碎片，必然导致画面错乱。于是我思考：==是否存在能同时移动的"元素组"？==重新观察坐标变化，注意到(0,0)移动到(0,2)，而(0,2)又移动到(2,2)，(2,2)移动到(2,0)，最后(2,0)回到(0,0)——四个位置形成闭环！这个环形结构启示我：只要将四个相关元素作为整体旋转，就能避免覆盖问题。具体操作时，只需用临时变量保存其中一个元素，其余三个顺次填补空位，如同旋转齿轮的四个齿牙。
接下来面临实施策略的选择。==矩阵能否整体一次性旋转？ ==实验发现，若尝试同时处理所有元素，环形链会相互缠绕。比如3x3矩阵中，(0,1)需要移动到(1,2)，但(1,2)又属于另一个闭环。这促使我想到分层策略：把矩阵想象成洋葱，从外层向内逐层剥离处理。对于每层，用top/bottom/left/right四个指针标记边界，这样就把复杂问题分解为多个相似子问题。
现在聚焦到单层旋转的细节。假设当前层是3x3的最外层，边长L=3。==需要循环处理多少个元素？== 四个角点已构成闭环基础，每条边只需处理L-1个非角点元素。例如顶部边，从left到right-1的位置都需要旋转。这里的关键洞察是：用偏移量i同步控制四条边的对应位置。当处理顶部边的第i个元素(left+i)时：
它对应左侧边的bottom-i位置（从下往上数对），应底部边的right-i位置（从右往左数），对应右侧边的top+i位置（从上往下数）；
于是旋转流程变得清晰：先用temp暂存左上角元素，然后将左下角元素移到左上角，右下角补到左下角，右上角补到右下角，最后将temp放回右上角。这个过程像转动门把手，四个角落随之联动。完成所有偏移量后，边界指针同时内缩，进入下一层。当top越过bottom或left越过right时，说明所有层已处理完毕。
值得注意的细节是矩阵中心点的处理。当矩阵尺寸为奇数时，最内层单点无需旋转；为偶数时，所有层都能完整分解为四元组。这种分层方法天然适应两种情况。
### 细节：
- **如何处理奇数阶矩阵的中心点？**
    当n为奇数时，矩阵有中心点（坐标为(n/2, n/2)），中心点不需要旋转，因此旋转层数为n/2（整数除法），中心点会自动被排除在旋转范围之外
### 步骤：
1. 我们初始化四个边界指针：`top=0`、`bottom=n-1`、`left=0`和`right=n-1`，它们定义了当前处理层的范围；
2. 们进入一个循环，条件是左边界小于右边界（left < right），这确保了至少还有一层需要处理。在每层处理中，我们计算需要旋转的元素组数：(right - left)，这对应于该层边长减1。然后，我们进入内层循环，索引i从0到(right-left-1)，每次处理一组四个元素：左上角(top, left+i)、右上角(top+i, right)、右下角(bottom, right-i)和左下角(bottom-i, left)；
3. 将左上角元素存入临时变量`temp`，然后将左下角元素移动到左上角位置，接着将右下角元素移动到左下角位置，再将右上角元素移动到右下角位置，最后将临时变量中的原始左上角值放入右上角位置。完成当前层的所有元素旋转后，我们将边界向内收缩：`top++`、`bottom--`、`left++`和`right--`，准备处理下一层；
4. 这个循环持续进行，直到左边界不再小于右边界，此时所有层都已处理完毕

下面是代码的具体实现：
![[Pasted image 20250624002543.png]]
### 知识点：
矩阵、数组