![[Pasted image 20250628165312.png]]
### 思路：
这道题要求我们找到基因序列中重复序列的部分，还规定了该序列长度为固定的10，最容易想到的当然是逐层进行字符串匹配，先取前十位作为参照字符串，再逐一向后进行匹配，若匹配到或者已经遍历到字符串的末尾则立即将参照字符串向后移，但这样遍历很显然时间复杂度和空间复杂度都比较高，==那么具体如何提高这道题目的解决效率呢？==我们可以遍历字符串中所有长度为10的子串，用哈希表记录每个子串出现的次数，最后输出出现超过一次的。但马上会意识到，当字符串很长时，存储大量子串会消耗巨大内存，效率低下，==如何优化存储空间呢？==关键在于DNA序列的特殊性：它只有四种核苷酸。这提示我们可以将每个字符编码为数字：A=00，C=01，G=10，T=11。这样每个长度为10的子串只需要20位二进制数就能表示，相当于一个整数。于是，我们不必存储整个子串，只需存储对应的整数，空间消耗从O(n)骤降到固定大小，==接下来，如何高效计算这些整数？==这时滑动窗口的灵感浮现了，我们不需要为每个子串重新计算整个10字符的编码，而是像传送带一样移动窗口。具体来说，当窗口向右滑动一位时，只需将当前整数左移两位（相当于去掉最左边的字符），再加上新字符的编码，最后用20位的掩码确保数据不溢出。这种增量计算使时间复杂度保持在O(n)。==那么如何记录出现次数呢？==既然整数范围是0到2^20-1（1048576），我们直接创建这个大小的整数数组作为哈希表。每当窗口滑动更新整数后，就增加对应数组位置的计数值。但要注意我们只需在计数达到2时记录结果，因为超过2次的重复记录会造成冗余，最后要解决结果输出问题。当某个子串计数达到2时，我们直接从原字符串中提取这个子串，虽然我们有整数编码，但不需要反向解码，只需记住当前窗口的起始位置，复制10个字符即可。同时为每个结果字符串单独分配内存，便于后续释放。
### 细节：
- **如何检测重复子串**？
    创建大小为2^20=1,048,576的整数数组作为直接寻址表：数组下标对应子串的整数编码，值表示出现次数，当hash[key] == 2时（非>2），记录子串，避免重复记录。
- **何时截取结果子串**？
    在滑动窗口过程中，当`hash[key]`首次达到2时，直接从原字符串截取：`strncpy(sub, s + i - 9, 10)`，不反向解码整数，避免计算开销。
### 步骤：
1. 首先检查DNA序列的长度是否满足基本要求。如果序列长度不超过10个字符，说明不可能存在符合条件（长度10且重复出现）的子串，此时直接返回空结果；
2. 创建一个包含104万8576个元素的整数数组作为哈希表，这个固定大小的数组能够覆盖所有长度为10的DNA子串可能的编码值；其次预分配一个结果指针数组，其容量基于序列长度计算得出（最大可容纳n-9个结果）；
3. 将"A"映射为二进制00，"C"映射为01，"G"映射为10，"T"映射为11。这种2位编码方案使得每个长度为10的子串都能用唯一的20位整数表示；
4. 从序列起始位置开始，首先计算前10个字符的整数编码：按顺序读取每个字符，通过左移位操作逐步构建20位的完整编码，并应用位掩码确保数值范围正确。将这个初始编码记录在哈希表中，标记为首次出现；
5. 每次移除最左侧字符的编码（通过左移2位实现），同时加入新字符的编码（通过位或操作实现），再应用掩码保持20位长度。每生成一个新编码，就在哈希表中增加对应位置的计数值。当发现某个编码的计数值恰好达到2时（即第二次出现），立即执行关键操作：从原始DNA序列的当前位置前9个字符处截取10个字符，复制到新分配的内存中，添加字符串终止符，并将这个子串指针存入结果数组；
6. 当整个DNA序列遍历完成后，释放哈希表占用的内存，返回结果数组及其实际长度。最终调用方在读取结果后，需要负责释放每个子串的内存以及结果数组本身。
下面是代码的具体实现：
![[Pasted image 20250628202059.png]]
### 知识点：
滑动窗口、哈希表、位运算