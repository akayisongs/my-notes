![[Pasted image 20250715232642.png]]
### 思路：
煎饼排序这道题乍看有些棘手，因为翻转操作被限制在数组前缀，但当我换个角度思考时，突然豁然开朗：既然只能操作前缀，==何不从数组尾部开始逆向构建有序序列？==这就像盖房子先打地基——从最底层开始逐层向上施工才稳固。我首先想象一个具体例子：假设数组是[3,2,4,1]，目标是将它变成[1,2,3,4]。如果直接处理开头，前缀翻转会影响后续元素；但若从末尾入手，每次固定最大值后，这部分就不再变动，如同拼图时先固定边缘再填充内部。==那么具体如何操作呢？==我联想到冒泡排序中最大值"上浮"的过程，但煎饼翻转的规则完全不同。经过反复推演，终于构思出关键的两步翻转策略：首先定位当前未排序部分的最大值，若不在开头就通过一次翻转将其送到数组起始位置，紧接着再通过第二次翻转将其精准"空降"到目标位置。以[3,2,4,1]为例，最大值4在索引2处。第一步翻转前3个元素（k=3），使数组变为[4,2,3,1]——这就像用铲子把深埋的宝藏翻到表面；第二步翻转整个未排序部分（k=4），瞬间将4送到末尾得到[1,3,2,4]，宛如魔术师将顶部的牌精准插入牌堆底部。
但这里产生新的疑问：==为什么必须分两步？==我尝试直接翻转发现根本行不通，因为翻转操作具有"牵一发而动全身"的特性。比如想直接把4移到末尾，但翻转规则只允许操作前缀，这种限制反而启示我：既然不能直达目标，就设计中转站——先到起点这个"交通枢纽"，再换乘到终点。更妙的是，当最大值恰好在开头时，第一步就可省略；若已在目标位置，整轮操作都能跳过。这种灵活处理极大优化了步骤，类似导航系统自动规避冗余路线。
接下来思考遍历方向的选择。==试想若从前向后处理会怎样？==比如先固定最小值在开头，但后续翻转前缀时，这个辛苦归位的元素又会被打乱顺序——如同刚砌好的砖墙被推土机撞倒。而从后向前处理时，已归位的最大值永远沉在底部，后续翻转只影响上部元素，形成稳定的"沉淀效应"。这让我联想到鸡尾酒调制：密度大的成分自然下沉，上层无论怎样搅拌都不影响底层结构。
在实现细节上，如何记录操作序列也值得推敲。我决定采用即时记录策略：每次实际翻转时才记录k值，确保序列与实际操作完全同步。例如处理[3,2,4,1]时，首轮记录k=3和k=4；次轮处理[1,3,2]时记录k=2和k=3；末轮处理[2,1]只需k=2。有趣的是，这个序列([3,4,2,3,2])与题目示例([4,2,4,3])不同，但都是正确的——如同登山有多条路径，只要最终抵达山顶都算成功。
### 细节：
- **煎饼排序如何模拟真实煎饼翻转过程？**
    这恰是算法的精妙之处，可以想象厨师用锅铲煎饼的场景：当发现最大的煎饼不在顶部时，需插入铲子将其翻到顶层（对应第一步翻转）；再插入更深的铲子将整叠煎饼翻转，使大煎饼沉底（对应第二步翻转）。这种物理世界的操作被抽象为两条核心规则，第一是每次只能翻转数组前缀，第二是翻转次数需最小化；
- **为何无法通过单次翻转完成定位？**
    这是由翻转规则的刚性限制决定的。由于只能反转0到k-1区间，无法直接操作中间元素。若试图单次将最大值移到底部，往往会导致小元素错位。例如试图直接将[3,2,4,1]的4移到底部，必须先用k=3将其翻到开头（得[4,2,3,1]），再用k=4完成沉底。这种"两步走"策略是突破约束的唯一途径。
### 步骤：
1. 初始化结果数组并设置操作计数器，用于记录翻转序列；
2. 从数组末尾向前遍历，每次循环确定一个待排序区段（初始为整个数组，逐步缩小范围）。在当前区段内定位最大值索引，若其已在正确位置则跳过本轮操作；
3. 若最大值不在起始位，则翻转其所在位置之前的所有元素，使最大值到达数组开头，同时记录翻转长度k1，然后翻转整个当前区段，将开头元素（即最大值）移动到区段末尾，记录翻转长度k2；
4. 返回记录的翻转序列，该序列长度必在10倍数组长度范围内。
下面是代码的具体实现：
![[Pasted image 20250715234100.png]]
### 知识点：
贪心、数组

