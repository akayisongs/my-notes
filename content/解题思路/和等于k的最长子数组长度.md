![[Pasted image 20250629212923.png]]
### 思路：
对于这道题==最直观的暴力解法是否可行？== 脑海中立刻浮现出双重循环的场景——外层遍历子数组起点，内层遍历终点并累加计算和。但随即意识到，这种解法的时间复杂度高达O(n²)，一旦数组规模扩大（比如数万元素），计算量将呈爆炸式增长。这就像试图用镊子一粒粒搬运沙滩上的沙子，效率低下且不切实际。
接着，我追问自己：==能否找到更优雅的数学关系来优化？== 这时“前缀和”的概念如闪电般击中了我。我联想到，若定义前缀和数组prefix，其中prefix[i]表示前i个元素之和，那么子数组nums[i..j]的和可表示为prefix[j]-prefix[i]。问题便转化为寻找满足prefix[j]-prefix[i]=k的索引对，且j-i尽可能大。然而，这个转化看似巧妙，却仍未摆脱双重循环的阴影——因为仍需遍历所有(i,j)组合。这让我陷入沉思：==如何在O(1)时间内快速定位符合条件的索引？==
突然，哈希表的特性跃入思维视野。我进一步推演：==是否能用哈希表存储历史前缀和，实现常数级查询？ ==具体而言，当计算到位置j的前缀和S时，只需检查哈希表中是否存在键S-k。若存在，则对应的索引i与当前索引j的差值即为子数组长度。但新的困惑产生了：若有多个相同前缀和，该记录哪个索引？ 经过实例验证（如数组[1,-1,0]），我恍然大悟——记录最早出现的索引才能最大化子数组长度。例如前缀和0出现在索引-1和2时，选择-1能使子数组延长3个单位。此时，一个关键边界条件浮出水面：==如何处理从数组头开始的子数组？== 设想整个数组和恰好为k的情况。我意识到需要建立“虚拟起点”——将前缀和0的位置初始化为-1。这如同在数组起点前设置一个锚点，当后续出现前缀和k时，便能通过j-(-1)=j+1正确计算全长。这个洞察让逻辑链条瞬间闭合。
最后，我审视整体方案：==能否处理负数等复杂情况？ ==回忆示例[1,-1,5,-2,3]中正负交错的特性，我确认哈希表不依赖数组单调性，而双指针法在此失效。至此，完整思路成型：遍历数组时动态计算前缀和，用哈希表记录每个和的首现位置，通过查询S-k快速定位候选起点。整个过程仅需单次遍历，时间复杂度优化至O(n)，空间复杂度O(n)用于存储前缀和索引。
### 细节：
- **如何处理负数和哈希冲突**？
    前缀和可能为负，需要设计兼容负数的哈希函数；冲突不可避免，采用线性探测法解决。同时注意到只需在第一次遇到前缀和时记录位置，因为后续相同值不会产生更优解。整个算法只需遍历数组一次，时间复杂度优化到O(n)，空间复杂度O(n)。
### 步骤：
1. 初始化关键变量
- 创建哈希表用于存储前缀和及其首次出现的索引位置
- 初始化当前前缀和 `sum = 0`
- 将初始键值对 `(0, -1)` 存入哈希表（表示在数组起始位置前，前缀和为0）
- 初始化最大子数组长度 `max_len = 0`
2. 遍历数组元素
   对数组中每个元素 `nums[i]`（索引 `i` 从0开始）顺序执行以下操作：
    **更新前缀和**：将当前元素值累加到前缀和 `sum += nums[i]`
    **计算目标值**：设定目标值 `target = sum - k`
    **查询目标值**：在哈希表中查找 `target` 是否存在
- 若存在，获取其索引值 `pos`
- 计算当前子数组长度 `curr_len = i - pos`
- 比较并更新最大长度 `max_len = max(max_len, curr_len)`
    **更新哈希表**：
- 检查当前前缀和 `sum` 是否已存在于哈希表中
- 若不存在，将 `(sum, i)` 键值对存入哈希表（只记录首次出现位置）
 3. 处理特殊边界情况
- **子数组从首元素开始**：初始设置 `(0, -1)` 确保当整个数组和等于k时，能正确计算长度（`len = n - (-1) = n+1-1=n`）
- **重复前缀和处理**：当相同前缀和多次出现时，保留最早出现的索引位置（保证后续计算得到最大长度）
4. 返回最终结果
- 完成数组遍历后，返回记录的 `max_len` 值
- 未找到符合条件的子数组（即 `max_len` 保持初始值0），返回0
下面是代码的具体实现：
![[Pasted image 20250630002316.png]]
### 知识点：
哈希表、前缀和、数组