![[Pasted image 20250617162332.png]]
### 思路：
这道题上来就有个关键的前提要求是**时间复杂度为O（n）**，如果是O（n^2）则很好处理，只需要初始化一个最小正整数为一，然后遍历数组有无为最小正整数的数，有的话最小正整数加一，继续循环遍历直至找不到，如果没有则返回该数；==**那么这道题该如何优化时间效率呢**？==我突然想到如果将其排好序之后再进行遍历就可以降低其时间效率了，但是还需要考虑排序算法的时间效率，==**时间效率最高的是哪个算法呢**？==我们学过的排序算法最高也只有*希尔排序*是将近O（n），没有达到要求，==那还有别的优化方法吗？==还有，既然不能用额外空间，**能否原地改造数组来模拟哈希表的功能呢**？我联想到哈希表的本质是“**键值映射**”，而数组下标天然就是键，因此，一个灵感闪现：如果我把数字1放在索引0，数字2放在索引1，以此类推，那么扫描时位置不匹配的数就是缺失的。但马上新疑问来了，==**如何实现这种“位置对齐”而不浪费空间**？==可以通过交换操作，遍历数组，将每个有效正整数交换到其理想位置，比如把数字3换到下标2的位置。不过，这里有个陷阱：交换后当前位置的新元素可能需要再处理，所以我得谨慎地只在未交换时才移动索引，否则可能遗漏关键值，接着，==**数组中的“干扰项”如负数、零或超大数怎么处理呢**？==它们并不影响最小正整数查找，所以我设定条件，只关注值在1到n之间的元素，但如果有重复元素（如[1,1]），**怎么才能避免死循环呢**？于是我添加一个检查，只有当目标位置的元素不等于当前值时才交换，这样重复值就不会引发无限循环，那么==**如何找到缺失值**？==那就第二遍扫描数组，第一个索引i不满足nums[i] == i+1时，i+1就是答案。如果所有位置都正确呢？比如[1,2,3]的n=3，此时缺失的必是4，因此，若扫描无异常，直接返回n+1。
### 细节：
- **题目要求 O(1) 空间，但哈希表需要 O(n) 空间，如何解决的呢？**
    将数组索引转化为哈希键值，建立映射关系：  `理想位置 = 数值 - 1`  ，
    通过交换操作让数字归位（如数字 3 放置索引 2），利用数组自身存储空间实现哈希功能，避免额外空间消耗。
### 步骤：
1. **初始化遍历**  
    设置索引 `i = 0` 开始扫描数组，准备将有效正整数归位
2. **元素归位操作**  
    对每个位置 `i` 执行：
    - 若当前值 `nums[i] ∈ [1, n]`（有效范围），且 `nums[i] ≠ i+1`（不在正确位置），且 `nums[i] ≠ nums[nums[i]-1]`（目标位置值不同，避免死循环），则交换 `nums[i]` 和 `nums[nums[i]-1]` 的值
3. **索引移动控制**
    - 若发生交换：保持 `i` **不变**（新元素需重新检查）
    - 若未交换：`i++` 继续扫描
4. **完成位置校准**  
    重复步骤2-3直到遍历结束，此时：
    - 所有有效值 `x ∈ [1, n]` 都位于索引 `x-1` 处
    - 无效值（负数/超范围）留在非常规位置
5. **扫描查找缺失值**  
    第二次遍历数组：
    - 检查每个位置 `i`
    - 当发现首个 `nums[i] ≠ i+1` 时 ，则返回 `i+1`
6. **处理完整序列**  
    若所有位置均满足 `nums[i] = i+1` ，则返回 `n+1`
下面是代码的具体实现：
![[Pasted image 20250617213527.png]]
### 知识点：
哈希表、数组