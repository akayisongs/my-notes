![[Pasted image 20250710213227.png]]
### 思路：
这道题核心在于找到同时包含两个目标节点的最小子树。但接着产生疑问：==如何在递归中传递这种包含关系？==通过回溯算法，我可以自底向上地传递信息——当遇到目标节点时立即返回，这样就能在回溯路径中标记出包含目标节点的子树。
深入思考递归过程时，==递归终止条件应该是什么？==显然当遇到空节点或目标节点时应当返回，因为这意味着当前分支已包含目标节点。但新的困惑随之而来：==如何处理递归返回的信息？==想象一个节点接收左右子树的返回结果：若左右子树各返回一个目标节点，说明当前节点就是分叉点，即最近公共祖先；若只有一侧返回非空，说明两个节点都在该侧子树中。
考虑到边界情况时，我琢磨：==当某个节点自身就是目标节点时如何处理？==这引发出关键洞察——若当前节点是目标节点之一，即便另一个节点在其子树中，它也是最近公共祖先。比如示例2中节点5是节点4的祖先，当递归到节点5时直接返回自身，上层的父节点通过左右子树结果判断出节点5就是解。实现过程中，我反复推敲递归逻辑：==为什么不需要显式判断目标节点是否在子树中？==因为递归的返回值已经隐含了这种信息：非空返回值意味着该子树至少包含一个目标节点。这种设计巧妙地避免了额外的判断，比如当左子树返回节点5，右子树返回空时，说明两个节点都在左子树中，且节点5就是它们的最近公共祖先。
测试算法正确性时，我模拟复杂场景：==若两个节点分别位于左右子树深处会怎样？==以示例1为例，递归到节点3时，左子树返回节点5（目标节点），右子树返回节点1（目标节点），此时满足"左右都不为空"的条件，正确返回节点3作为公共祖先。这种分而治之的策略，正是二叉树递归的精髓所在。
最后我思考效率问题：==这种解法的时间复杂度如何？==由于每个节点只访问一次，时间复杂度是O(n)，完全满足105节点的约束。而空间复杂度取决于递归栈深度，在最坏情况（链状树）下是O(n)，平均情况则是O(log n)。
### 细节：
- **如何递归处理子树？**
`TreeNode* left = lowestCommonAncestor(root->left, p, q); `
`TreeNode* right = lowestCommonAncestor(root->right, p, q);`
   - **后序遍历**：先处理左右子树再处理当前节点
   - **返回值含义**：
     - 非 NULL：该子树包含至少一个目标节点
     - NULL：该子树不含目标节点
### 步骤：
1. **递归终止条件判断**
    - 若当前节点为空（`root == NULL`），直接返回空指针
    - 若当前节点就是目标节点`p`或`q`，返回当前节点（自身就是祖先）
2. **递归搜索左子树**
    - 向左子树递归调用该函数函数：`left = lowestCommonAncestor(root->left, p, q)`
    - 获取左子树中目标节点的存在情况
3. **递归搜索右子树**
    - 向右子树递归调用该函数：`right = lowestCommonAncestor(root->right, p, q)`
    - 获取右子树中目标节点的存在情况
4. **结果合并与LCA判断**
    - **情况1**：左右子树均找到目标节点（`left != NULL && right != NULL`）
        - 说明当前节点是分叉点 → 返回当前节点作为LCA
    - **情况2**：仅左子树找到目标节点（`left != NULL`）
        - 返回左子树结果（LCA在左子树中）
    - **情况3**：仅右子树找到目标节点（`right != NULL`）
        - 返回右子树结果（LCA在右子树中）
5. **结果返回**
    - 将最终确定的LCA节点返回给上层递归
    - 递归结束时返回根节点的LCA判断结果
下面是代码的具体实现：
![[Pasted image 20250711003008.png]]
### 知识点：
二叉树、dfs
