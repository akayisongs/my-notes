![[Pasted image 20250602214527.png]]
### 思路：
这道题我首先想到问题是，*如何去获得二叉树中各节点的值呢*？可以采用后序遍历的方法来完成，这样可以保证一定能将整个二叉树完全遍历，所以在开始的时候可以先将根节点的左右子树通过该函数递归记录最长连续序列长度，*那么如何找到与该节点相邻的节点呢*？很显然其左右子节点即是其邻接点，*那么如何解决连续的问题呢*？我们可以在判断其左右孩子是否为空的同时加上对该节点的值和其非空孩子节点的值相差是否唯一来确定，如果相邻且连续，那该节点左(右)子树最长连续序列(包括其本身)应该等于其左(右)孩子节点的最长连续序列加一，*那么这里的左(右)孩子节点的最长连续序列如何得来呢*？应该是通过递归函数的返回值来实现的，那么对于一个节点来说，*其最长连续序列和左右子树最长连续序列有什么关系呢*？其最长连续序列应该等于左右子树最长连续序列中更长的一个，还有由于每次递归时传回的参数是该节点的最长连续序列，可以设置一个全局参数max_len，通过不断更新其值，保证最后得到的根节点的最长连续序列个数不会出现错误，*还有什么要注意的特殊情况吗*？注意输入二叉树为空时，直接返回0。

### 步骤：
1. 初始化节点在左右方向上的路径长度；
2. 检查左子节点和右子节点是否有可以扩展的路径；
3. 取左右方向上的最大值作为当前节点的最长连续序列长度；
4. 更新全局最大值；
5. 使用函数递归计算左右子树的最长连续序列长度。
具体代码实现如下：
![[Pasted image 20250603151353.png]]

### 知识点：
二叉树及其基本操作、深度优先搜索思想