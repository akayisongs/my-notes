![[Pasted image 20250619182115.png]]
### 思路：
这道题题目给出了一个有序数组，需要原地删除重复元素，但有个特殊条件每个元素最多只能出现两次，而不是完全去重。最终返回新数组的长度，同时要确保数组的前半部分是正确的。这里的关键是“原地”操作，意味着我不能创建新数组来存储结果，那么，**“原地”操作又该如何实现呢**？我回忆起处理数组问题的常见技巧，双指针法。既然数组已经排序，重复元素肯定是连续出现的，我可以用一个快指针遍历数组，一个慢指针标记有效位置。这样，通过比较元素值，就能在遍历中“跳过”多余的重复项，同时避免大规模的数据移动。不过需要注意，不能像普通去重那样只保留唯一元素，而是允许最多两次重复。那么**双指针具体怎么设计才能保证每个元素不超过两次呢**？假设慢指针指向新数组的写入位置，快指针负责扫描原数组。关键是，当快指针遇到一个元素时，我需要判断它是否已经出现过两次。一个聪明的办法是：比较当前元素（快指针指向的）和慢指针前两个位置的元素是否相同。如果相同，说明这个元素已经重复两次了，应该跳过；如果不同，就可以保留并写入慢指针位置。这样一来，慢指针之前的元素都满足“最多两次”的规则，因为每次写入前都做了检查。这方法既利用了数组有序的特性，又避免了复杂操作。**可是，这样的逻辑会不会有漏洞**？比如数组很短或元素很少的情况？确实，我得考虑边界条件。如果数组长度小于等于 2，根本不需要处理，因为最多两个元素不可能超过两次重复，直接返回原长度就行。另外，快指针从索引 2 开始遍历，因为前两个元素无论如何都是合法的。这样，我就能覆盖所有情况，确保算法健壮性。实际上，这种思路不仅高效，还能维持时间复杂度在 O(n)，毕竟只遍历一次数组，空间复杂度也是 O(1)，只用了几个指针变量。
### 细节：
- **数组有序这一条件如何帮助解题？**
    有序性意味着重复元素必然相邻出现。这一特性让我意识到：只需比较当前元素和已处理部分的末尾元素，即可判断重复次数，无需全局统计。这是双指针解法成立的前提，也是区别于无序数组去重的关键。
- **为什么慢指针从2开始？如何处理前两个元素？**
    数组前两个元素无需处理：即使重复，也满足"最多两次"；如果不重复，更无问题。因此慢指针初始化为 2，相当于已承认前两个元素的合法性。这避免了对数组头部特殊处理，保证算法一致性。
### 步骤：
1. 判断数组长度是否小于等于 2。如果是，直接返回数组长度，因为不可能有重复超过两次的元素；
2. 初始化两个指针：慢指针设为 2（因为前两个元素不需要检查），快指针也设为 2（从第三个元素开始扫描）；
3. 快指针从 2 开始逐个遍历数组元素。每次比较快指针当前元素与慢指针前两个位置的元素是否相同，如果这两个元素不同，将快指针的值复制到慢指针位置，同时将慢指针向前移动一位，如果这两个元素相同，快指针继续前进但慢指针保持不动（跳过这个多余重复项）；
4. 重复上述比较和复制操作，直到快指针遍历完整个数组；
5. 最后，返回慢指针的值作为新数组的长度，此时数组前慢指针个元素就是处理后的结果。

下面是代码的具体实现：
![[Pasted image 20250619223225.png]]
### 知识点：
双指针、数组