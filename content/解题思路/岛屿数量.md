![[Pasted image 20250630203921.png]]
### 思路：
这道题题目描述了一个由"1"和"0"组成的网格，需要统计岛屿数量。我意识到这本质上是一个图论中的连通分量问题——每个"1"代表图中的节点，相邻的"1"之间存在边。那么核心问题就变成了：==如何高效地找出图中所有孤立的连通区域？== 这个理解很关键，因为它直接决定了后续的解决方法选择。
接着我开始思考：==应该用什么算法来解决连通分量问题？== 深度优先搜索（DFS）和广度优先搜索（BFS）立即浮现在脑海中。考虑到DFS的递归实现简洁明了，能够直观地模拟"探索岛屿"的过程，我决定采用DFS方案。具体来说，每当我遇到一个未被访问的陆地格子（'1'），我就会启动DFS遍历，像探险家一样深入探索所有相连的陆地，并将它们标记为已访问（改为'0'），这样每个DFS启动点就对应一个岛屿。确定算法后，我开始构思实现细节：==DFS的具体实现需要哪些关键要素？== 首先是递归终止条件：当超出网格边界或遇到水域（'0'）时停止递归。其次是方向控制：定义四个方向（上下左右）来探索相邻单元格。最后是状态标记：在访问陆地格子后立即将其标记为'0'，避免重复访问。这些要素构成了DFS的核心逻辑。
随着思路深入，我考虑到：==如何处理边界情况和性能问题？== 网格可能为空，所以需要添加空网格检查。网格最大300×300=90000个单元，递归深度可能达到90000，虽然系统栈可能承受，但为安全起见，我确保递归函数尽可能轻量。此外，我计划使用方向数组来简化代码并提高可读性。
在准备编码时，我想到：==如何验证算法的正确性？== 这需要设计测试用例：全水域网格应返回0；单个陆地应返回1；题目示例中的"+"形陆地需要确保四个方向连通不被重复计数；还有"回"形岛屿要验证中心水域是否能正确分隔岛屿。这种测试思维来自以往调试经验——边界情况往往隐藏着最棘手的bug。
### 细节：
- **关于状态标记，需要额外存储访问状态吗**？
    实际上可直接修改原网格，将访问过的'1'改为'0'，这样既避免重复访问又节省内存。这类似于"就地操作"思想，但需注意题目是否允许修改输入数据——本例中允许，因为函数签名无const限定。
### 步骤：
1. 初始化岛屿计数器
    设置计数器count初始值为0
    准备遍历整个二维网格
2. 遍历网格单元格
使用双层循环遍历每个单元格：
    外层循环遍历行（i 从 0 到 gridSize-1）
    内层循环遍历列（j 从 0 到 gridColSize[i]-1）
3. 发现新岛屿
当遇到未访问的陆地（'1'）时：将岛屿计数器count加1，启动深度优先搜索（DFS）过程
4. 深度优先搜索淹没岛屿，递归访问当前陆地的四个相邻方向：
    上方（i-1, j）
    下方（i+1, j）
    左侧（i, j-1）
    右侧（i, j+1）
对于每个访问位置：
    检查是否在网格范围内
    检查是否为未访问的陆地（'1'）
    将访问过的陆地标记为水域（'0'）
5. 递归终止条件
    当前单元格超出网格边界
    当前单元格是水域（'0'）
    当前单元格已被访问过（已标记为'0'）
6. 完成网格遍历
    继续扫描网格直到所有单元格处理完毕
    确保每个岛屿只被计数一次
7. 返回岛屿数量
    将最终计数值count作为结果返回
下面是代码的具体实现：
![[Pasted image 20250701002543.png]]
### 知识点：
dfs、数组、矩阵