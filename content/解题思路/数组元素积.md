![[Pasted image 20250604214910.png]]
### 思路：
这道题关键是记录下来后续元素的乘积最大的值，题目要求对数组中的每个元素A[i]，计算它与后续所有元素（包括自身）乘积的最大值。关键在于"后续元素"这个限定条件，我们只需要考虑j≥i的A[j]，这就意味着每个元素A[i]对应的计算范围是不断缩小的子数组[i,n-1]。这种从当前位置到数组末尾的子数组特性提示我们，应该采用从后向前处理的方式。那么为什么从后向前处理更高效呢？因为当我们处理位置i时，需要知道子数组[i, n-1]的极值信息。如果从后往前处理，我们可以在遍历过程中动态维护这些信息。具体来说，当我们处理到位置i时，后续元素[i+1, n-1]的极值已经计算并保存好了。这样就避免了每次重复扫描整个子数组，从而将时间复杂度从O(n²)降低到O(n)，对于这个算法如何动态更新关键信息呢？在从后向前遍历过程中，我们维护两个关键变量，max_val和min_val。每处理一个新位置i时，首先用A[i]更新这两个极值，如果A[i]比当前max_val大，就更新max_val；如果比min_val小，就更新min_val。接着根据A[i]的正负性决定计算方式：非负数则取A[i]max_val，负数则取A[i]min_val，这样就能在单次遍历中完成所有计算，注意最后一个元素直接平方存入最大数组中。

### 步骤：
1. 先处理空数组的情况以及处理数组中最后一个数；
2. 从倒数第二个元素向前遍历，更新子数组 [i, n-1] 的最大值和最小值；
3. 根据 A[i] 的正负性计算 res[i]。
具体代码实现如下：
![[Pasted image 20250605000051.png]]

### 知识点：
数组，时间空间复杂度