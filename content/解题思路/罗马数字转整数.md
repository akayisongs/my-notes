![[Pasted image 20250618203720.png]]
### 思路：
对于这道题，**罗马数字的基本规则是什么？** 我知道到它有七种基础字符对应特定数值，如I=1、V=5等。更关键的是那些特殊规则：当小数字出现在大数字左边时，表示减法而非加法，例如IV代表4。这让我进一步思考：**如何区分正常情况和特殊情况？** 我发现核心在于相邻字符的大小关系，若当前字符值小于右侧字符值，就触发减法规则。那么**转换算法的整体框架该如何设计？** 既然需要处理每个字符的数值和相邻关系，最直接的方法是遍历字符串。但在遍历过程中，**如何动态决定加减操作？** 这里我想到一个精妙的方法：比较当前字符与下一个字符的值。如果当前值小于下一个值，说明遇到特殊情况，应减去当前值；反之则加上当前值。例如IX中，I(1)<X(10)，所以先减1，后续再加10，最终得到9。**如何处理字符串末尾的字符？** 由于末尾字符没有下一个字符可比较，直接加上其值即可。这又引出另一个疑问：**为什么不需要单独处理特殊组合？** 因为减法规则已隐含在相邻比较中，比如"CM"（900），C(100)<M(1000)触发减100，后续M会加1000，净效果正是900。
### 细节：
- **整个算法的效率如何**？
    间复杂度O(n)，空间复杂度O(1)，因为只遍历一次字符串。
### 步骤：
1. **创建数值映射表**
    - 初始化一个256大小的整型数组（覆盖ASCII字符范围）
    - 设置罗马字符与整数的对应关系：
        - 'I' → 1
        - 'V' → 5
        - 'X' → 10
        - 'L' → 50
        - 'C' → 100
        - 'D' → 500
        - 'M' → 1000
2. **初始化结果变量**
    - 创建整数变量`result`并初始化为0
    - 获取输入字符串的长度`len`
3. **遍历字符串字符**
    - 使用索引`i`从0到`len-1`循环处理每个字符
    - 对于每个字符`s[i]`：  
        a. 检查是否存在下一个字符（`i+1 < len`）  
        b. 获取当前字符值`current = values[s[i]]`  
        c. 获取下一个字符值`next = values[s[i+1]]`
4. **判断加减规则**
    - **特殊情况（当前值 < 下一个值）**：
        - 将当前值从结果中减去（`result -= current`）
        - 例如："IV"中，I(1) < V(5) → 减去1
    - **正常情况（当前值 ≥ 下一个值）**：
        - 将当前值加到结果中（`result += current`）
5. **处理末尾字符**
    - 当遍历到最后一个字符时：
        - 直接将其值加到结果中
6. **返回最终结果**
    - 遍历完成后，返回累加的`result`值
下面是代码的具体实现：
![[Pasted image 20250619000950.png]]
### 知识点：
哈希表、字符串