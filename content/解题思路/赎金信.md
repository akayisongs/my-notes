![[Pasted image 20250621214357.png]]
### 思路：
对于这道问题，**它的核心问题是什么**？需要判断ransomNote中的所有字符是否都能在magazine中找到足够的数量，***换句话说***，magazine是否包含ransomNote的完整字符集，所以问题的本质是字符资源的供需匹配：magazine提供字符资源，ransomNote消耗这些资源，而关键约束是每个字符只能使用一次，那么**如何高效地验证这种字符匹配关系**？考虑到字符串由小写字母组成这个重要特性，我想到可以用一个+"，字母表只有26个字符，创建一个26个元素的计数数组再合适不过了，这个数组就像26个储物格，每个格子存储对应字母的数量，我计划先扫描magazine填充"资源库"，再扫描ransomNote消耗资源，这样就能直观看到资源是否充足，**那么具体如何实现呢**？首先初始化计数数组为全零，这相当于清空资源库，接着遍历magazine字符串，每遇到一个字符，就在对应格子增加计数，相当于入库操作，然后遍历ransomNote字符串，每遇到一个字符就减少对应格子的计数，相当于出库操作，最关键的是，在出库时要实时检查：如果某个格子的计数在减少后变为负数，说明该字符供不应求，立即判定匹配失败，**这里为什么应该选择数组呢**？因为这里数组要比哈希表更高效，**那如果遇到重复的字符或者字符顺序不同怎么办呢**？无论字符在字符串中如何排列，只要最终计数匹配就满足条件。重复字符自动处理：比如ransomNote有两个'a'，计数数组在检查时会连续减少两次'a'的计数。如果magazine有足够'a'，计数保持非负；如果不足，负数状态立即暴露问题。
### 细节：
- **有没有边界情况需要特别注意？**
    有两个边界很关键：一是空字符串情况，但题目保证最小长度为1；二是资源刚好用完的情况。当遍历完ransomNote后所有计数都非负，说明资源充足。值得注意的是，magazine可能有剩余字符，但这不影响结果。
### 步骤：
1. 初始化一个长度为26的整型数组作为字符资源库，对应26个小写字母的库存量并清零；
2. 遍历`magazine`字符串，对每个字符计算其索引值（字符-'a'），在数组对应位置增加计数；
3. 遍历`ransomNote`字符串，对每个字符同样计算索引值，在数组对应位置减少计数，每当减少计数后立即检查该位置：若数值小于0，说明当前字符供不应求，立即终止流程返回`false`；
4. 若完整遍历`ransomNote`后所有字符计数均保持非负，则确认资源充足，返回`true`。
下面是代码的具体实现：![[Pasted image 20250622002726.png]]
### 知识点：
计数、字符串