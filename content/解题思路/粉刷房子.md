![[Pasted image 20250608210240.png]]
### 思路：
这道题关键在于如何找到其在约束条件下粉刷房子的最小花费，因为每个房子的颜色选择会影响后续选择，具有典型的子问题重叠特性，这让我联想到动态规划方法，那么如何定义状态才能准确描述问题呢？可以采用二维状态表示：设dp i j为粉刷前i+1个房子且第i个房子使用颜色j时的最小花费。其中j取值0、1、2分别对应红、蓝、绿三种颜色。这样定义既能记录当前状态，又能体现颜色约束。那状态之间通过怎样的函数转移呢？关键在于相邻颜色不能相同的约束。因此，当我计算第i个房子选择颜色0时，前一个房子只能是颜色1或2，于是状态转移方程为dp i 0= min(dp i-1 1, dp i-1 2) + costs i 0。同理可得其他颜色的转移方程。这样每个状态都基于前一个状态的最优解，确保了决策的最优性。关于初始状态，第一个房子没有相邻约束，所以dp 0 0、dp 0 1、dp 0 2直接等于各自粉刷成本。之后从第二个房子开始，按照状态转移方程逐步计算每个位置的最小花费。最终结果就是最后房子三种颜色花费中的最小值。有哪些特殊情况吗？当没有房子时花费为0。同时由于每个状态只依赖前一个状态，空间复杂度可优化到O(1)，但为清晰表达算法思想，代码中保留了完整的DP数组。
### 步骤：
1. 定义动态规划的状态，即设定一个二维数组`dp[i][j]`，其中`i`表示第`i`个房子，`j`表示三种颜色（红、蓝、绿），该状态代表粉刷前`i+1`个房子且第`i`个房子使用颜色`j`时的最小花费。接着进行初始化：对于第一个房子（`i=0`），其三种颜色的花费直接取自成本矩阵，即`dp[0][0] = costs[0][0]`，`dp[0][1] = costs[0][1]`，`dp[0][2] = costs[0][2]`；
2. 进入状态转移阶段：从第二个房子开始遍历所有房子，对于每个颜色`j`，计算当前花费时需考虑前一个房子不能使用相同颜色的约束，因此状态转移方程为`dp[i][j] = min(dp[i-1][其他两种颜色]) + costs[i][j]`；
3. 在遍历完成后，最终结果即为最后一个房子三种颜色状态的最小值，即`min(dp[n-1][0], dp[n-1][1], dp[n-1][2])`；
4. 需要处理边界情况：若没有房子（`n=0`），直接返回花费`0`。

下面是代码的具体实现：
![[Pasted image 20250608211857.png]]
### 知识点：
动态规划、数组、贪心思想