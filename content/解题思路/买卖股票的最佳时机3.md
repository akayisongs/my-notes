![[Pasted image 20250627234454.png]]
### 思路：
我首先思考的是问题本质：==如何在一个价格波动的时间序列中，通过两次独立的买卖操作实现利润最大化？==不同于无限次交易的简单累加，两次交易的限制意味着必须找到两个最优的非重叠时间段。于是我问自己：==两次交易的时间关系是什么？==显然，它们必须完全分离，即第一次卖出后才能第二次买入。这让我想到可以将整个时间段分成前后两段，每段完成一次交易。
==那么如何分割时间序列呢？==我意识到需要遍历所有可能的分割点。例如，若将分割点设在第i天，则第一次交易发生在[0, i]区间，第二次在[i+1, n-1]区间。但紧接着产生新问题：==如何高效计算每个子区间的最大利润？==这让我联想到经典的“一次交易”股票问题——通过动态维护最低买入价计算最大价差。于是决定预处理两个数组：left_max记录从左到右每个位置的单次交易最大利润，right_max记录从右到左的对应值。
在具体实现left_max时，我遇到关键细节：==如何处理价格持续走低的情况？==比如某天价格创历史新低，但利润可能为负。此时必须坚持“不亏本”原则，通过与前一天利润比较确保left_max非负。同样，构建right_max时从右向左扫描，需动态维护峰值价格，并特别注意边界值——最后一天无法买入故利润为0。
完成预处理后，核心问题变成：==如何合并结果？==初始最大利润设为整个区间单次交易的值（即left_max末尾元素），然后遍历所有分割点计算left_max[i] + right_max[i+1]。这里我突然意识到易错点：若整个序列单调递增，单次交易可能优于分割交易，因此必须比较合并结果与单次交易值。例如[1,2,3,4,5]中，单次交易利润4大于任意分割方案（如1+3=4）。
验证算法时，我反复推演示例[3,3,5,0,0,3,1,4]：当分割点为第3天时，左区间利润2（5-3），右区间利润4（4-0），总和6；而分割点为第5天时，左区间利润3（3-0），右区间利润3（4-1），同样得到6。这确认了算法能捕捉非连续利润点。最后检查边界情况，如空数组返回0，持续下跌市场利润为0，确保逻辑严密性。
### 细节：
- **为什么需要两个方向扫描**？
    单方向扫描只能处理单次交易：
     左→右扫描：仅能计算以某天为卖出点的最大利润
     右→左扫描：仅能计算以某天为买入点的最大利润
    双向扫描确保了左数组覆盖所有"以i为终点"的交易，而右数组覆盖所有"以i为起点"的交易，组合时完美衔接两个独立交易区间。
### 步骤：
1. 首先检查价格数组的长度。如果数组长度小于或等于1，说明没有足够的交易日进行有效交易，直接返回0利润。这是整个算法的初始判断，避免后续无效计算；
2. 为两个辅助数组分配内存空间：
    左利润数组：存储从起始日到当前日的最大单次交易利润
    右利润数组：存储从当前日到结束日的最大单次交易利润；
3. 从左向右遍历价格数组：初始化最低价格为第一天的价格，然后从第二天开始遍历：动态更新遇到的最低价格，计算当天卖出可能获得的利润（当天价格减去最低价格），还要将当前利润与前一天的最大利润比较，取较大值存入左利润数组；
4. 从右向左遍历价格数组：初始化最高价格为最后一天的价格，然后从倒数第二天开始向前遍历：同样动态更新遇到的最高价格，计算当天买入可能获得的利润，最后将当前利润与后一天的最大利润比较，取较大值存入右利润数组；
5. 遍历所有可能的分割点，对于每个分割点i，取左利润数组[i]作为第一笔交易利润（时间区间[0,i]），如果i+1在数组范围内，取右利润数组[i+1]作为第二笔交易利润（时间区间[i+1,结束]），计算两次交易利润之和并持续跟踪并更新最大利润值；
6. 释放为左右利润数组分配的内存空间，返回计算得到的最大利润值。
下面是代码的具体实现：
![[Pasted image 20250628002514.png]]
### 知识点：
数组、动态规划、分治思想