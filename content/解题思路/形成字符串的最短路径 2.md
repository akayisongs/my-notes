![[Pasted image 20250615234705.png]]
### 思路：
这道题的关键在于高效地将目标字符串拆分为尽可能少的子序列片段，每个片段必须都是源字符串的子序列。==**那么如何实现这一目标呢**？==目标字符串的每个字符都必须在源字符串中找到匹配，且匹配顺序必须满足子序列要求，如果目标字符串中出现源字符串没有的字符，则直接判定不可能，返回-1，最直接的方法是逐个字符匹配，但这样效率太低。==**那么还有什么处理办法吗**？==我们可以采用空间换时间的思路，先预处理源字符串为每个字符记录其在源字符串中出现的所有位置（按顺序存储）。
当开始匹配目标字符串时，我们维护一个"当前指针"表示在源字符串中的匹配位置。==**如何遍历目标串中的字符呢**？==可以通过二分查找在其位置数组中寻找第一个大于当前指针的位置。若找到，则更新指针继续匹配；若找不到，说明当前子序列无法延伸，此时需要开启新的子序列（计数+1），并将指针重置为源字符串起始位置重新匹配该字符。**这里的关键在于贪心策略：尽可能延长每个子序列，从而最小化总数量。**
**二分查找在此发挥核心作用**是它将单次匹配的时间复杂度从O(n)优化至O(log n)，使算法能高效处理长字符串。例如当指针位置靠后时，二分查找能快速定位是否存在后续匹配位置。若遇到位置数组为空的情况（即字符不存在），则立即返回-1，若遍历完成，实际子序列数量等于重置次数+1。因为最后一次重置后仍有一个子序列未被计数。整个过程只需遍历目标字符串一次，配合预处理的位置数组，实现O(m log n)的时间复杂度（m为目标串长度，n为源串长度），空间复杂度O(n)用于存储位置信息。
### 细节：
- **如何最大化每个子序列的长度？**
    采用贪心策略：维护当前在源字符串中的查找位置指针。遍历目标字符串时，对每个字符在其位置列表中二分查找第一个大于等于当前指针的位置。若找到则更新指针继续匹配；若找不到则开启新子序列（计数+1），重置指针为0并重新匹配当前字符（确保每个字符都被处理）。这种策略确保每个子序列尽可能长，从而最小化总数。
- **开启新子序列时如何避免遗漏字符？**
    当某字符在当前子序列中匹配失败时，我们开启新子序列并重置指针为0，但不移动目标字符串的索引——这意味着下一轮循环会重新尝试匹配同一字符。这保证每个字符最终都会被某个子序列匹配，且新子序列从源字符串开头重新开始。
### 步骤：
1. 首先遍历源字符串`source`，为每个字符（a-z）构建有序位置列表。使用二维数组`positions[26]`存储，其中每个元素是该字符在源字符串中出现的所有位置（按升序排列）。例如对于`source="abc"`，字符'b'的位置列表为`[1]`；
2. 设置子序列计数器`count = 1`（至少需要1个子序列），当前匹配位置指针`current_end = 0`；
3. 若当前字符在source中不存在（对应位置列表为空），立即返回-1，在当前字符的位置列表中，查找第一个≥ current_end的位置，更新current_end = 匹配位置 + 1，未找到匹配：序列计数count++（需要开启新子序列），重置current_end = 0，重新查找当前字符在源字符串中的第一个位置，更新current_end = 新匹配位置 + 1；
4. 遍历完成后返回计数器count，其值即为所需的最小子序列数量。
下面是代码的具体实现：
![[Pasted image 20250616005817.png]]
### 知识点：
贪心、字符串
