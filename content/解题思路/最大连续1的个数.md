![[Pasted image 20250615142743.png]]
### 思路：
这道题是要解决最多翻转一个零的二进制数组最大连续1的个数，==**观察这类序列我们能发现什么呢**？==我们能发现最大序列个数会出现在有连续1的周围，具体判断的时候我们会发现当遇到某数为第一次遇到的1时，我们还需要比较其下一个和下下一个数字是否为1。
==**如何做到记录三个元素呢**？==我们应该想到需要设置三个指针，类似于滑动窗口问题，通过左右两个指针定义窗口边界，右指针负责扩展窗口，左指针负责收缩窗口，确保窗口内始终不超过一个0。==**当右指针遇到0时如何处理**？==如果这是窗口内的第一个0，我们可以保留它；但如果窗口内已有0，就必须移动左指针到前一个0之后的位置，从而保证新0的加入不会违反规则，==**那还有一个指针该如何使用呢**？==我们需要记录上一个0的位置。当遇到新0时，若已有记录的上一个0，就将左指针移动到上一个0的下一位，然后更新上一个0的位置为当前新0的位置。这样就能确保窗口内始终只包含最新的一个0。==**那么如何计算最大长度**？==每次移动右指针后，无论是否遇到0，都计算当前窗口长度（右指针减左指针加1），并与历史最大值比较。这样就能在遍历过程中持续更新最大长度。==这道题目还有个进阶要求是输入的数字是作为 **无限流** 逐个输入如何处理？==换句话说，内存不能存储下所有从流中输入的数字。==**这种方法是否满足进阶要求**？==由于只需遍历一次数组，且仅需常数空间记录指针位置，完全适合处理无限流数据。每个新元素到来时，只需常数时间更新指针和长度信息，无需存储历史数据。
### 细节：
- **如何优化时间复杂度？**
    我们可以使用滑动窗口技术。核心思想是维护一个动态窗口，窗口内最多只允许存在一个0（代表最多翻转一个0）。窗口右指针不断向右扩展，遇到0时进行特殊处理，确保窗口始终满足条件。
- **为什么这种移动策略有效？**
    因为当遇到新0时，如果窗口内已有0，必须将前一个0移出窗口，否则窗口内会有两个0（违反最多翻转一个0的规则）。通过将`left`移到前一个0之后，我们确保窗口内始终只保留最新的一个0，这是获得最长连续序列的关键。
### 步骤：
1. 初始化左指针left=0，最大长度max_len=0，上一个0的位置prev_zero=-1（表示还没有遇到0）。
2. 遍历数组（右指针right从0开始）：
   a. 如果当前元素nums[right]为0：

    如果prev_zero不为-1（说明之前已经有一个0在窗口内），那么我们将左指针移动到prev_zero+1（因为此时窗口内有两个0，我们需要把前一个0移出窗口，所以左边界移动到前一个0的下一个位置）；
    更新prev_zero为当前的right（记录当前0的位置）；

   b. 计算当前窗口的长度：current_len = right - left + 1，并更新max_len。
3. 返回max_len
下面是代码的具体实现：
![[Pasted image 20250615235902.png]]
### 知识点：
滑动窗口、双指针