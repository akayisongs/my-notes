![[Pasted image 20250627205055.png]]
### 思路：
这道题需要理解二进制加法的本质，它和十进制加法类似，但进位规则基于2而非10，这意味着每一位相加后，如果和达到2或3，就会产生进位。那么，输入是字符串形式，==**那么该如何处理它们**？==既然加法通常从最低位开始，而字符串是从左到右存储的，我就需要从两个字符串的末尾向前遍历，这样才能对齐相同位权的位置，不过，字符串长度可能不同，这时较短的字符串前面可以视为补零，这样就能统一处理，确保每一位都有对应的数字参与计算，==进位问题该怎么管理？==我意识到需要一个变量来跟踪进位值，初始设为0。在每一位计算时，我先将两个字符串的当前字符转换为数字（'0'转0，'1'转1），再加上进位值，然后求和。这个和除以2的商就是新的进位，而余数就是当前位的值，需要转换为字符存储。例如，计算1+1时，和是2，进位为1，当前位为0。这样，进位就能动态传递到下一位的运算中。然而，当两个字符串都遍历完后，==如果还有进位未处理怎么办？==我必须在循环条件中包含进位检查，这样最后会多添加一位'1'，避免遗漏最高位的进位。==结果字符串如何正确构建？==由于我从最低位开始计算，存储的顺序是反的，比如"11"加"1"的中间结果是"001"，这显然不对。因此，在得到所有位后，我必须反转整个字符串，让最高位在左端。同时，我需要考虑特殊情况：如果两个字符串都是"0"，反转前结果为空，这时得额外添加一个'0'，否则会输出空字符串。另外，内存分配也很关键，我应预留足够空间，包括可能的进位和结束符，最后，==如何确保代码高效且可靠==？我采用从后向前的遍历方式，时间复杂度与较长字符串的长度成正比，空间复杂度也类似，因为结果字符串可能略长。
### 细节：
- **如何处理二进制加法中的进位传递**？
    二进制加法的核心在于进位管理。需要动态维护进位标志，初始值为0。计算每一位时，将两个字符串当前位的数值（0或1）与前一位的进位值相加，得到总和。该总和除以2的商作为新的进位值，余数作为当前位的实际结果。例如计算位值1+1+进位1时，总和3除以2得商1（新进位）、余1（当前位值）。这个进位会传递到下一位计算中。
### 步骤：
1. 首先获取两个输入字符串的长度，计算最大长度用于确定结果字符串的初始空间。为结果分配足够的内存空间：最大长度 + 2（可能的进位位） + 1（字符串结束符'\0'）。初始化关键变量：进位标志carry设为0，两个指针分别指向两个字符串的末尾（即最低位），结果写入位置pos初始化为0；
2. 从最低位开始向最高位循环处理：获取当前位值：通过三元运算符处理不等长字符串：若指针有效（≥0），取对应字符并转换为数字（'0'→0，'1'→1）；若指针已超出起始位置（<0），自动补0计算当前位和：将两个当前位值与进位值相加：sum = digit_a + digit_b + carry；更新进位：根据二进制规则：carry = sum / 2（整除2获取进位值）；存储当前结果：计算当前位实际值：sum % 2，转换为字符后存入结果缓冲区（此时顺序为逆序）；循环持续条件：任一字符串还有未处理位或进位标志非零（确保最高位进位不遗漏）
3. 检查结果缓冲区是否为空（pos == 0）：若为空（如"0"+"0"的情况），手动添加'0'字符，若非空，继续后续流程，此步骤确保全零输入返回正确结果"0"；
4. 在结果缓冲区有效内容末尾添加字符串结束符'\0'，符合C语言字符串规范；
5. 因计算顺序为低位到高位，需反转结果：设置左指针指向结果首字符，设置右指针指向最后一个有效字符，左右指针向中间移动并交换字符，重复直到左指针≥右指针。此操作将逆序存储的二进制位转换为正常顺序（最高位在左）；
6. 将处理完毕的结果字符串指针返回。
下面是代码的具体实现：
![[Pasted image 20250627215636.png]]
### 知识点：
字符串、位运算