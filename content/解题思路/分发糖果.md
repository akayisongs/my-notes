![[Pasted image 20250704202914.png]]
### 思路：
这道题题目中提到每个孩子至少一颗糖，相邻孩子中评分更高的必须得到更多糖果。目标是找到最小糖果总数。规则看似简单，但当我尝试在脑海中模拟几个例子时，立刻遇到了矛盾点，相邻关系是双向的，而孩子的评分分布可能是任意的。比如示例中[1,0,2]的情况，如果只考虑从左到右分配，第二个孩子得到1颗糖看似合理，但这样第一个评分更高的孩子就和第二个孩子糖果数相同了，明显违反规则。这让我意识到单方向思考是行不通的。==那么如何兼顾左右两侧的关系呢？==我联想到"山峰与山谷"的关系，假设孩子们站成的队伍像连绵的山脉，评分高的孩子是山峰，评分低的是山谷。每个山峰的糖果必须高于两侧山谷，而连续山峰之间还有坡度关系。比如评分序列[1,3,2]中，3就是山峰，1和2是两侧山谷。==但如果是像[1,2,2]这样的"平顶山"呢？==相邻的评分相同时，规则其实没有强制要求糖果数必须相同或不同，这意味着我们可以灵活处理以节省糖果。这个发现很关键：评分相等时，保持糖果数相同或更少都能满足规则，而选择更少的糖果显然有利于最小化总数。接着我开始构思具体解法。==首先每个孩子给1颗糖是最基础的起点，但如何调整呢？==如果同时考虑左右会陷入混乱，于是可以分两步走。第一步从左到右扫描：当发现右边孩子评分比左边高时，就让他的糖果比左边多1颗。这样处理完后，像[1,3]这样的递增序列就满足了，因为3会得到2颗糖。但此时递减序列还是错的，比如[3,1]中第二个孩子只有1颗糖，虽然比左侧少，但规则要求评分更高的3应该比1拿更多糖，现在3只有1颗显然不够。==那么如何进行补救呢？==这时可以从右到左扫描，这次重点关注左边评分高于右边的情况。但有个精妙之处在于：如果某个孩子左边评分更高，不能简单地直接给他加糖，而要看他右边邻居的糖果数。比如在[3,1]中，当从右向左检查到第一个孩子时，发现他评分3高于右边的1，而右边孩子只有1颗糖，那么第一个孩子至少需要2颗糖。但更复杂的是像[1,3,2]的情况：在第一步从左扫描后，糖果可能是[1,2,1]——此时中间孩子已经2颗糖。当从右向左扫描到中间孩子时，发现他评分3比右边2高，但现有糖果2已经大于右边的1，所以不需要调整。这种"取现有值与邻居值+1的较大值"的策略，既能保证不破坏第一步的结果，又能补充缺失的约束。想到这里，==如果出现长距离的递减序列会不会有问题？==比如[5,4,3,2,1]。第一步从左到右后糖果全是1，第二步从右向左时：倒数第二个孩子发现比右边高，糖果变成2；倒数第三个发现比右边高，糖果变成3...依此类推，最终形成[5,4,3,2,1]的糖果分配，完美匹配评分递减的坡度。这验证了算法的鲁棒性。而评分相等的情况更让我安心也是这样，像[2,2]这样的组合，两步扫描都不会增加糖果数，保持各1颗糖，既合规又节约。最后我反思整个方案：通过两次方向相反的遍历，实际是在模拟我们"先顾左再顾右"的决策过程。第一次保证每个孩子不会亏待右边的邻居，第二次保证不会亏待左边的邻居。而关键洞察在于：当评分出现峰值时（如[1,3,2]中的3），需要同时承接来自左右两侧的约束，所以必须两次扫描才能捕获完整依赖关系。这样可以处理分阶段不对称的约束。
### 细节：
- 这个问题的核心难点是什么？为什么不能只从头到尾遍历一次就解决？
    核心难点在于，每个孩子的糖果数量需要 **同时满足和他左、右两位邻居的关系**。如果你只从左到右遍历一次，当你为一个孩子 `C` 根据他左边的邻居 `L` 分配好糖果后，你无法保证这个数量也满足他和他右边邻居 `R` 的关系。
- 如何通过两次遍历解决双向约束？其核心思想是什么？
    采用**分治思想**，通过两次独立遍历分别处理左右约束：
1. **从左到右遍历**：处理所有"右>左"的递增关系
    - 若`ratings[i] > ratings[i-1]`，则`candies[i] = candies[i-1] + 1`
    - **作用**：确保所有右侧更高的孩子糖果数严格递增（如`[1,3]`→糖果`[1,2]`）
2. **从右到左遍历**：处理所有"左>右"的递减关系
    - 若`ratings[i] > ratings[i+1]`，则`candies[i] = max(candies[i], candies[i+1] + 1)`
    - **关键设计**：取`max`保证不破坏前次遍历结果（如`[3,1]`→糖果从`[1,1]`修正为`[2,1]`）
    **为什么有效**：  
    两次遍历分别覆盖了"递增坡"和"递减坡"，而**波峰**（如`[1,3,2]`中的3）会在第二次遍历中被重新校准，确保同时满足左右约束。
### 步骤：
1. **初始化糖果数组**  
    创建一个长度与评分数组相同的糖果数组，为每个孩子分配1颗糖果作为基础值。这确保满足"每个孩子至少分配到1个糖果"的最低要求；
2. **从左向右遍历处理递增关系**  
    从第二个孩子开始向右扫描，比较每个孩子与左侧邻居的评分。若当前孩子评分严格高于左侧邻居，则将其糖果数调整为`左侧邻居糖果数+1`。此步骤确保所有右向递增序列（如[1,2,3]）满足评分越高糖果越多的条件；
3. **从右向左遍历处理递减关系**  
    从倒数第二个孩子开始向左扫描，比较每个孩子与右侧邻居的评分。若当前孩子评分严格高于右侧邻居，则将其糖果数更新为`max(当前糖果数, 右侧邻居糖果数+1)`。此步骤关键点在于取最大值操作，既保证满足左向约束，又不破坏前次遍历的结果；
4. **处理评分相等的特殊情况**  
    当遇到相邻孩子评分相等时，保持糖果数不变。因为规则仅要求评分更高者糖果更多，对平分的孩子无额外约束，保持1颗糖果即可最小化总数。此策略在类似[1,2,2]的序列中尤为重要；
5. **计算糖果总数**  
    将最终调整后的糖果数组中所有数值累加，所得总和即为需要准备的最少糖果数目。此时数组已同时满足左右双向约束和最小化要求；
6. **验证边界条件**  
    - 单元素数组直接返回1
    - 全等值数组（如[3,3,3]）结果应为数组长度
    - 严格递减序列（如[5,4,3,2,1]）结果应为等差数列和。
下面是代码的具体实现：
![[Pasted image 20250704222819.png]]
### 知识点：
贪心、数组、分治思想