![[Pasted image 20250620004052.png]]
### 思路：
要解决这个原地移除数组指定元素的问题，首先需要理解核心要求：必须在原始数组上操作，不能创建新数组；移除所有等于给定值的元素后，剩余元素可以任意排列；只需要保证前k个元素是保留值，并返回数量k。**那么如何实现呢**？最直接的想法是用双指针技巧，一个指针从左边扫描，另一个从右边控制边界。当左指针遇到要移除的值时，就用右指针指向的元素覆盖它，这样就能把无效元素"推"到数组尾部。**具体如何实现呢**？初始化左指针在起点0，右指针在终点数组长度，然后开始循环：当左指针位置的值等于目标值时，将右指针前移一位并用该位置的值覆盖左指针位置；若左指针位置的值不等于目标值，则左指针后移一位继续扫描。**何时停止呢**？这样循环直到两个指针相遇，此时左指针的位置就是保留元素的数量k。
### 细节：
- **如何保证所有元素都被处理？**
    覆盖后左指针不移动：当左指针位置被新值覆盖后，下一轮循环会立即检查这个新值。如处理 [2,2,3] 时，第一次覆盖后仍是 2，会再次触发覆盖直到获得非目标值。
- **为什么用覆盖而非交换？**
    虽然效果相似，但覆盖操作更高效：直接赋值比交换少一次写操作。例如当左指针遇到 2 时，用右指针的值覆盖当前值（nums[left]=nums[right-1]），比交换（需三次赋值）更节省资源。
### 步骤：
1. 初始化两个指针：左指针设为0（从数组开头开始扫描），右指针设为数组长度（标记有效区间的边界）；
2. 进入循环处理：只要左指针小于右指针，就检查左指针当前位置的值；
3. 如果该值等于目标值`val`，说明需要移除，于是将右指针前移一位，并用该位置的值覆盖左指针当前位置的值（这样就把无效元素移到后面了），如果该值不等于`val`，说明需要保留，直接将左指针右移一位（扩大保留区间）；
4. 重复上述比较和覆盖操作，直到左指针不再小于右指针（即两指针相遇）；
5. 返回左指针的值作为保留元素的数量k，此时数组前k个元素就是所有不等于val的值（顺序可能改变），而k之后的元素无需处理。
下面是代码的具体实现：
![[Pasted image 20250620005700.png]]
### 知识点：
数组、双指针