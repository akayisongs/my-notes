![[Pasted image 20250613161437.png]]
### 思路：
这道题要解决计算每个学生最高五科成绩平均分的问题，首先，**如何高效处理混合的学生分数数据呢**？可以通过二级排序，将记录按学生ID升序排列，使相同ID的分数自然聚拢；再按分数降序排列，确保每个学生组内高分在前。那么接下来**如何准确提取前五名分数呢**？在遍历排序数组时，只需为每个学生累加前五个分数即可，因为降序排列保证前五个就是最高分。**但遇到学生切换时如何处理**？通过实时跟踪当前学生ID，当检测到ID变化时立即结算前一个学生的平均分，用累加和除以5（整数除法），然后重置计数器和新学生数据。**整数除法会导致小数位数损失怎么办**？这正是题目要求，如88.6必须截断为88，因此必须在除法前完成累加。**为何结果自然满足ID递增**？由于初始排序已确保ID从小到大，遍历顺序就是输出顺序，无需额外排序。
### 细节：
- **如何优化空间效率？**
    采用"排序+单次遍历"策略，避免存储所有学生的完整分数列表。遍历时仅需记住当前学生状态，结算后即释放，极大节省内存。例如处理万条记录时，内存占用仅线性增长。
### 步骤：
1. 创建学生结构体存储原始数据：`id` 字段保存学生ID，`score` 字段保存单科分数， 创建结果结构体存储计算结果，`id` 字段对应学生ID`avg` 字段存储五科平均分；
2. 将输入的二维数组转换为学生结构体数组，动态分配内存存储转换后的数据，遍历原始数据填充结构体数组；
3. 使用快速排序对结构体数组排序：主排序键：学生ID升序（从小到大），次排序键：分数降序（从高到低），确保同一学生的分数按从高到低排列；
4. 初始化遍历状态变量：current_id 跟踪当前处理的学生ID（初始-1），sum 累计当前学生分数总和，count 记录已处理科目数，遍历排序后数组：遇到新学生：结算前一个学生的平均分（sum/5），同学生高分科目：累加前五个分数（count<5时），同学生低分科目：跳过第六科及以后科目（count>=5时）；
5. 检查是否有未结算的学生，计算最后一个学生的平均分（sum/5），将结果存入结果数组。

下面是代码的具体实现：
![[Pasted image 20250614001158.png]]
### 知识点：
数组、哈希