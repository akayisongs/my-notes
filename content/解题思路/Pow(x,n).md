![[Pasted image 20250701234132.png]]
### 思路：
这道题关键的问题是当指数 n 很大时，直接循环 n 次相乘效率太低，比如计算 2 的 100 次方需要 100 次乘法，这在计算机中是不可接受的，那么，==**有没有更高效的方法呢**？==于是我想到了数学中的指数法则：当计算 x 的 n 次方时，如果 n 是偶数，可以将其拆分为 (x²) 的 n/2 次方。例如 2¹⁰ 等价于 (2²)⁵ = 4⁵。这样每次指数减半，计算量就大大降低了。==这里当 n 是奇数时该怎么办？==比如 4⁵ 可以拆为 4 × 4⁴，这样就能继续分解为 4 × (4²)² = 4 × 16²。通过这种二分思想，计算复杂度从 O(n) 降到了 O(log n)，接着我意识到需要处理负指数的情况：当 n 为负数时，结果应该是 x⁻ⁿ 的倒数。比如示例 3 中 2⁻² = 1/4 = 0.25。但这里有个关键陷阱：当 n = INT_MIN 时，直接取负会导致整数溢出，==如何处理呢？==我决定先将 n 转换为 long long 类型再取负，这样就能安全处理边界情况了，然后，==如果指数 n 恰好为零怎么办？==根据数学定义，任何数的零次幂都是 1，所以直接返回 1.0。==如果底数 x 是零呢？==这里需要分情况：零的正数次幂仍是零，但零的负数次幂在数学上是未定义的，就返回正无穷大 (1.0/0.0)。
### 细节：
- **为何选择迭代而非递归**？
递归虽直观但存在缺陷：
    空间浪费：递归深度 O(log n) 占用栈空间
    边界风险：大指数可能导致栈溢出
迭代法优势：
    仅需 3 个变量（result, x, N）
    空间复杂度 O(1)
    避免函数调用开销
### 步骤：
 1. **处理指数为零的特殊情况**
- 若指数 `n` 等于 0：
    - 根据数学定义，任何数的 0 次幂均为 1（包括 0⁰ 在编程中通常定义为 1）
    - 直接返回结果 `1.0`
2. **处理底数为零的特殊情况**
- 若底数 `x` 等于 0.0：
    - **当指数为正**：0 的正数次幂为 0 → 返回 `0.0`
    - **当指数为负**：0 的负数次幂未定义（数学上趋近无穷大）→ 返回正无穷大（`1.0/0.0`）
3. **处理负指数**
- 若指数 `n` 为负数：
    1. **取底数的倒数**：`x = 1 / x`
    2. **将指数转为正数**：`n = -n`
    3. **关键细节**：当 `n = INT_MIN` 时，直接取负会导致整数溢出
        - **解决方案**：用 `long long` 类型存储指数（`long long N = n`）

4.  **初始化变量**
- 将转换后的指数存入 `long long N`（避免溢出）
- 初始化结果变量：`double result = 1.0`
5. **快速幂迭代计算**
循环执行以下操作，直到指数 `N` 降为 0：
6. **检查当前位是否为 1**：
    - 若 `N` 是奇数（`N % 2 == 1` 或 `N & 1`）：
        - 将当前底数乘入结果：`result = result * x`
7. **底数平方更新**：
    - 计算下一轮底数：`x = x * x`
8. **指数折半更新**：
    - 右移一位：`N = N / 2`（或位运算 `N >>= 1`）
9.  **返回最终结果**
- 当 `N` 降为 0 时，循环结束
- 返回累积结果 `result`
下面是代码的具体实现：
![[Pasted image 20250702000503.png]]
### 知识点：
迭代法、数学