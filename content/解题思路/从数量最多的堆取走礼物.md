![[Pasted image 20250616160337.png]]
### 思路：
这道题**要求我做什么呢**？首先其核心操作是给定一个礼物数组，每秒需要选择当前数量最多的那堆礼物，将其数量减少到原来数量的平方根并向下取整，重复这个过程k次后计算剩余礼物的总数，所以这道题**关键在于"每次定位最大值"这个操作**，
那么，**如何高效找到最大值呢**？考虑到数组长度最大为1000，而操作次数k也最多1000，最直接的方法是每次遍历整个数组寻找最大值。虽然使用优先队列理论上更高效，但C语言标准库没有现成实现，且数组规模不大，因此简单遍历的时间复杂度O(n×k)完全可接受。不过，需要特别注意的是每次修改最大值后，数组状态会更新，所以必须在每次操作时重新扫描整个数组，**平方根取整具体怎么实现**？这时我想到了数学函数sqrt()，但需要向下取整。于是回忆起C语言中可以将浮点数强制转换为整数来实现取整操作，不过好像有一点可以优化：当某堆礼物降为1后，因为sqrt(1)=1，后续操作不会再改变其值。这意味着一旦检测到当前最大值为1，就可以立即终止后续所有操作，避免不必要的计算。**操作过程中有哪些临界情况**？如果所有礼物初始值都是1，那么任何操作都不会改变数组；如果k=0，应该直接返回初始总和。还有礼物值可能很大，但经过几次平方根运算后会迅速减小到很小值，因此使用int存储中间结果完全足够，但最终求和需要用long long防止溢出。**最后如何计算结果**？完成k次操作后（或提前终止时），只需遍历数组累加剩余礼物数量。值得注意的是，由于每次操作只修改一个元素，不需要额外数据结构记录状态，直接使用原始数组即可。
### 细节：
- **关于操作过程中的优化**
    当某个堆的礼物数量降为1时，因为1的平方根仍然是1，所以后续操作不会再改变它的值。更重要的是，如果当前整个数组的最大值已经是1，那么无论进行多少次操作，数组都不会再变化。因此，可以在每次操作前检查最大值是否为1，如果是，就提前终止循环，避免不必要的操作。
### 步骤：
1. **初始化与边界处理**
    - 首先检查特殊情况：如果操作次数 `k` 为 0，直接返回礼物总和
    - 准备循环计数器，开始进行最多 `k` 次操作
2. **最大值定位**
    - 每次操作开始时，遍历整个礼物数组
    - 使用变量记录当前最大值及其索引位置
    - 通过比较更新最大值索引（当遇到更大值时更新）
3. **提前终止判断**
    - 在每次操作前检查当前最大值
    - 若最大值已降为 1，立即跳出循环，因为 1 的平方根仍是 1，后续操作不会改变结果
4. **平方根取整操作**
    - 对定位到的最大值执行平方根计算
    - 使用数学库函数 `sqrt()` 计算结果
    - 通过强制类型转换 `(int)` 实现向下取整
    - 更新数组中对应位置的数值
5. **结果计算**
    - 完成所有操作（或提前终止）后，遍历整个礼物数组
    - 使用 `long long` 类型累加求和
    - 返回最终的总和结果
下面是代码的具体实现：
![[Pasted image 20250617000854.png]]
### 知识点：
数组