![[Pasted image 20250702232939.png]]
### 思路：
这道题要求字符串在旋转180度后保持原样，这意味着每个字符必须能映射到一个对称字符，且整个字符串的结构必须对称，如"69"旋转后"6"变成"9"、"9"变成"6"，组合起来仍是"69"，因此符合要求，但并非所有字符都能满足这个条件，==那么哪些字符是有效的呢？==
显然，只有'0'、'1'、'6'、'8'、'9'是有效字符。这些数字在视觉上具有旋转对称性。具体来说，'0'、'1'、'8'这三个数字自身旋转180度后，形状保持不变，它们与自己构成一对完美的对称映射。而'6'和'9'则互为镜像，'6'旋转后变成了'9'，'9'旋转后则变成了'6'，它们彼此之间形成了对称关系。至于其他所有数字，如'2'、'3'、'4'、'5'、'7'等，它们在旋转180度后要么形状变得面目全非，不再像数字（如'2'或'7'），要么形状虽然保留但无法找到与之匹配的镜像（如'3'或'4'），因此，这些字符的存在会立即破坏中心对称的条件。
接下来，我们需要验证整个字符串的结构对称性，==如何验证整个字符串的对称性？==
一个直观且高效的方法是**双指针遍历**：我们设置两个指针，一个`left`从字符串的头部开始，另一个`right`从尾部开始，然后让它们同时向中间移动，逐对检查字符。在每一轮检查中，我们取`left`指针指向的字符和`right`指针指向的字符，验证它们是否满足对称映射关系。例如，对于"609"，我们首先检查`left`指向的'6'和`right`指向的'9'，发现'6'旋转后正是'9'，符合要求。然后，两个指针继续向中间移动，直到它们相遇或交错。整个过程只需要进行一次遍历，时间复杂度为`O(n)`，显著优于任何嵌套循环的暴力方法。
然而，如果字符串的长度是奇数，会有一个中心字符，==但如果字符串长度是奇数怎么办？==
此时，当两个指针最终在中间相遇时，我们需要对这个唯一的中心字符进行特殊处理。这个中心字符必须是**自对称**的，即它在旋转180度后，其形状和值都保持不变。根据我们之前定义的有效字符，只有'0'、'1'和'8'满足这个条件。'6'和'9'因为它们互为镜像，如果出现在中心位置，旋转后会变成另一个字符，从而打破与自己之间的对称关系，导致整个数字不再是中心对称数。例如，"6"旋转后是"9"，因此"6"本身不具有中心对称性。
在遍历过程中，我们还需要考虑遇到无效字符的情况，==如果遇到无效字符该如何处理？==
在进行双指针检查之前，我们可以先快速判断每个字符的有效性。一旦在字符串的任何位置发现一个不属于'0'、'1'、'6'、'8'、'9'的字符，比如"962"中的'2'，由于它不在有效字符列表中，我们就知道这个字符串不可能是一个中心对称数，此时可以**立即终止检查并返回`false`**，无需继续遍历。这种“快速失败”的策略能有效节省不必要的计算。
最后，为了高效地实现字符映射，==然后如何高效实现字符映射呢？==
一个非常实用的方案是预定义一个映射表。在C语言中，我们可以使用一个数组或`switch`语句来实现这种映射关系。例如，可以定义一个`char mapping[128]`数组，将`mapping['6']`的值设为`'9'`，将`mapping['9']`的值设为`'6'`，`mapping['0']`、`mapping['1']`、`mapping['8']`则分别映射到自身。这样，在双指针比较时，只需检查`num[left] == mapping[num[right]]`即可，这不仅提高了代码的可读性，也使得映射操作的查找效率接近`O(1)`。在实际实现中，我们还需要注意一些边界情况，==如空字符串是否有效？==根据定义，空字符串不存在任何不对称问题，可以被视为中心对称数，应直接返回`true`。而对于单字符字符串，如"1"，其本身是自对称的有效字符，因此也应返回`true`。这种全面的考虑确保了代码的健壮性和正确性。
### 细节：
- **该算法是否覆盖所有场景呢**？
    对于偶数长度如"69"，双指针成对检查；对于奇数长度如"101"，中心字符'0'的自对称性自动满足。整个过程通过逐步缩小检查范围，最终确认字符串的全局对称性。
### 步骤：
1. **处理空字符串特殊情况**  
    首先检查输入字符串是否为空（即首字符为终止符`\0`）。若是空字符串，按照定义视为对称，直接返回`true`；
2. **初始化字符映射表**  
    创建长度为256的字符数组（覆盖ASCII码范围），初始化为全0。设置有效字符的映射关系：
    - `'0' → '0'`
    - `'1' → '1'`
    - `'6' → '9'`
    - `'8' → '8'`
    - `'9' → '6'`  
    无效字符保持映射值为0（如`'2'`、`'5'`等）
3. **设置双指针**
    - 左指针`left`从字符串首字符开始（索引0）
    - 右指针`right`从字符串末字符开始（索引`strlen(num)-1`）
4. **开始循环检查（直到指针交错）**  
    当`left <= right`时循环执行以下操作：
    - **检查右字符有效性**：若`map[num[right]] == 0`（即右字符是无效字符），立即返回`false`
    - **检查对称映射**：若`num[left] != map[num[right]]`（左字符不等于右字符的映射值），返回`false`
    - **移动指针**：`left`向右移动一位，`right`向左移动一位
5. **循环结束处理**  
    若完整遍历字符串未发现违规：
    - 返回`true`（字符串是中心对称数）
下面是代码的具体实现：
![[Pasted image 20250702234918.png]]
### 知识点：
哈希表、双指针、字符串