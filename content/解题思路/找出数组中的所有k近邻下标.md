![[Pasted image 20250624225355.png]]
### 思路：
这道题关键是找出所有 K 近邻下标，**那么K 近邻下标的定义是什么呢**？它是数组中满足至少存在一个下标 j 使得 |i - j| <= k 且 nums[j] == key 的下标 i，这样的话应该先找到数组中所有等于 key 的下标 j，因为这些是作为参考点来判断其他下标是否符合条件的依据，接下来**该如何有效标记出所有符合条件的下标呢**？我想到了可以利用一个布尔数组来实现标记，那么如何遍历每个等于 key 的下标 j，然后将其周围 k 范围内的下标 i 都标记为 true，表示这些 i 是 K 近邻下标，不过，需要确保在标记的时候不会超出数组的边界，所以每次标记的时候都要判断 i 是否在数组的有效范围内，然后，**如何收集这些标记为 true 的下标呢**？我也可以再次遍历这个布尔数组，将对应下标收集起来，并且这些下标本身就是按递增顺序排列的，这样最终得到的结果就符合要求了。不过，在实际编写代码之前，**那么如何组织代码的结构呢**？首先，建立一个布尔数组来标记，然后收集满足条件的下标即可。
### 细节：
- **该算法是如何处理边界情况的**？
    在标记 K 近邻下标时，必须确保不会越界，即确保计算出的下标在数组的有效范围内（0 到 `numsSize - 1`），在标记时，计算范围的起始和结束位置，确保起始位置不小于 0，结束位置不大于 `numsSize - 1`。例如，对于下标 `j`，其标记范围的起始位置为 `max(j - k, 0)`，结束位置为 `min(j + k, numsSize - 1)`。
- **该算法是如何处理特殊输入的**？
    处理一些特殊情况，例如数组中所有元素都是 `key`，或者数组中没有元素等于 `key`，如果数组中所有元素都是 `key`，则所有下标都会被标记为 `true`，结果数组包含所有下标，如果数组中没有元素等于 `key`，则结果数组为空。
- **该算法是如何高效标记 K 近邻下标的**？
    找到所有等于 key 的下标后，需要确定哪些下标在其 k 范围内。这些下标即为 K 近邻下标。使用一个布尔数组 exists 来标记哪些下标是 K 近邻下标。布尔数组的长度与原数组相同，初始化为 false。对于每个等于 key 的下标 j，将其周围 k 范围内的所有下标 i 标记为 true。这样可以高效地记录哪些下标符合条件。
### 步骤：
1. 从头到尾遍历数组 nums，找出所有等于 key 的元素的下标，在遍历过程中统计等于 key 的元素个数，以便为存储这些下标分配合适的内存空间，创建一个数组 keyIndices 来存储所有等于 key 的下标；
2. 创建一个布尔数组 exists，长度与原数组相同，初始化为 false，用于标记哪些下标是 K 近邻下标，对于每个等于 key 的下标 j，将其周围 k 范围内的所有下标 i 标记为 true，注意处理边界情况，确保 i 不会超出0 到 numsSize - 1；
3. 遍历布尔数组 exists，统计其中 true 的个数，以确定结果数组的大小，创建结果数组 result，遍历布尔数组 exists，将所有为 true 的下标收集到 result 中；
4. 释放内存并返回结果。
下面是代码的具体实现：
![[Pasted image 20250624233312.png]]
### 知识点：
数组、动态分配内存