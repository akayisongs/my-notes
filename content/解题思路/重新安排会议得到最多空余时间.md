![[Pasted image 20250711211925.png]]
### 思路
这道题题目要求保持会议时长和相对顺序不变，仅允许平移操作。这意味着会议之间的前后关系像链条一样固定，但整条链条可以在时间轴上滑动。例如，有两个会议时，它们始终维持"会议A→会议B"的顺序，但我们可以整体前移或后移。这个特性提示我：最优解很可能出现在三种位置——第一个会议前、最后一个会议后或某两个会议之间。因为在这些边界处，我们最容易集中"腾挪"出大段空白时间。
然后，我遇到关键难题：**==如何高效验证某个空余时长X是否可行？**==直接枚举所有移动方案显然不现实（组合爆炸）。这时，二分答案法浮现在脑海——既然我们要求的是"最大"空余时间，那么可以将其转化为判定问题：==是否存在一种移动方案，使得最大空余时间≥X？==这个转化如同将"寻找最高山峰"变为"检查某高度是否有山峰"，瞬间降低了难度。我回忆起类似问题（如安排教室）中，二分法配合可行性检查往往能高效解决最值问题。
接下来，我聚焦于：==**可行性检查需要处理哪些核心场景？**== 基于之前的三种位置假设，我意识到必须分别处理：
1. **首会议前空档**：尝试从时间X开始紧凑安排所有会议。若会议原始开始时间与安排时间不同，则计为移动。若总移动次数≤k且结束时间≤eventTime，则可行;
2. **末会议后空档**：要求所有会议结束时间≤eventTime-X。这里需要动态规划计算最小结束时间：定义`dp[i][j]`表示前i个会议移动j次的最小结束时间。状态转移时，考虑是否移动当前会议——若移动则紧接前一会议结束；若不移动则需满足原始开始时间≥前一会议结束时间;
3. **会议间空档**：选定第i与i+1会议间的空档X。将会议分为前后两段：前段结束时间T需满足T+X+后段总时长≤eventTime。前段用动态规划求T，后段从T+X开始紧凑安排并计算移动次数。两段移动次数之和≤k则可行。
   在思考状态转移方程时，我反复推敲：**==如何处理'不移动会议'的约束？==** 这是最容易出错的点。当选择不移动会议时，其原始开始时间必须≥前一会议的结束时间，否则会产生冲突。例如前一个会议延迟结束可能侵占后一会议原始时间，此时必须移动后一会议来避免重叠。

### 细节
- **动态规划如何高效处理会议移动？**
   设计二维状态 `dp[i][j]` 表示前 `i` 个会议移动 `j` 次时的最小结束时间：
   - **不移动会议 `i`**：需满足 `startTime[i] ≥ dp[i-1][j]`（无重叠），结束时间=`endTime[i]`
   - **移动会议 `i`**：紧接前一会议结束，结束时间=`dp[i-1][j-1] + duration[i]`（移动次数+1） 
     _优化点_：通过后缀和数组 `back_sum[]` 快速计算后段会议总时长，加速边界检查。
- **可行性检查需要处理哪些核心场景**？
必须分别处理**首会议前空档**、**末会议后空档**和**会议间空档**
### 步骤
1. **预处理数据**：
    - 计算每个会议的持续时间 `dur[i] = endTime[i] - startTime[i]`
    - 计算后缀和数组 `back_sum`，存储从每个位置到末尾的会议总时长
2. **二分查找框架**：
    - 初始化搜索范围 `low = 0`, `high = eventTime`
    - 当 `low <= high` 时循环：
        - 计算中点 `mid = (low + high) / 2`
        - 检查 `mid` 是否可行：
            - 若可行：更新答案 `ans = mid`，扩大搜索范围 `low = mid + 1`
            - 若不可行：缩小搜索范围 `high = mid - 1`
3. **可行性检查**（三种情况）：
    - **首会议前空档**：从时间 `X` 开始紧凑安排所有会议，统计移动次数
    - **尾会议后空档**：使用动态规划计算前 `n` 个会议的最小结束时间，检查是否满足 `结束时间 ≤ eventTime - X`
    - **会议间空档**：枚举每个间隙位置，分别处理前后段会议：
        - 前段使用动态规划计算最小结束时间
        - 后段从 `T + X` 开始紧凑安排，统计移动次数
        - 检查前后段移动次数总和是否 `≤ k`
4. **动态规划实现**：
    - 状态定义：`dp[i][j]` 表示前 `i` 个会议移动 `j` 次的最小结束时间
    - 状态转移：
        - 移动当前会议：`新结束时间 = 前会议结束时间 + 当前会议时长`
        - 不移动会议：需满足 `原始开始时间 ≥ 前会议结束时间`
    - 初始化：`dp[0][0] = 0`，其他设为极大值
5. **返回结果**：
    - 二分结束后返回最大可行的空余时间 `ans`
    - 释放动态分配的内存

![[Pasted image 20250712000941.png]]![[Pasted image 20250712001027.png]]
![[Pasted image 20250712001106.png]]
### 知识点
动态规划、二分