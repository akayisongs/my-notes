![[Pasted image 20250616153933.png]]
### 思路：
这道题是要求找到数组nums1在nums2中对应元素，最容易想到的方法是：将两个数组逐层遍历，找到相同元素时将二者下标以**直接定址法**存入新数组，==**但这样的算法有什么问题呢**？==很显然它的时间复杂度将来到O（n^2），时间效率较低，==**有没有什么更高效的解决方案呢**？==再读一遍题目，我发现nums2数组只是将nums1数组中元素顺序打乱之后的数组，说明它本质上和原来的数组是一个数组，只是顺序不同而已，==**那么如果数组num1中有重复的元素怎么办呢**？==这样的话直接使用第一种算法就完全不行了，这样的话，我们应该需要某种机制来记录每个元素在nums2中的所有出现位置，并且在使用后及时标记这些位置已被占用，避免重复使用，那么我们**如何高效记录元素位置呢**？最简易直观的方法当然是创建哈希表来存储，遭遇冲突时可通过**链地址法**来存储，具体来说，我们可以为nums2构建一个哈希表，其中键是元素值，值是该元素在nums2中出现的位置列表，==**那么如何确定哈希表大小呢**？==首先，由于元素是整数，选择**除留余数法**是不错的选择，但是还是比较难以确定一个具体的空间，那我们可以先将其令为数组长度的两倍，既能减少冲突可能性，又能避免空间大量损失，最后，==**如何构建最终映射**？==完成哈希表构建后，现在该处理nums1了。对于nums1 中的每个元素，首先通过哈希函数找到对应的槽位，然后取出链表中的第一个节点，这个节点就存储着该元素在 nums2 中的一个有效位置，==**将这个位置记录到结果数组后，必须立即从链表中移除该节点，为什么呢**？==因为这样才能确保相同的元素下次会匹配到不同的位置，整个过程就像在玩配对游戏：每次从袋子里取出一个位置，使用后就不能再用了。==**还有什么要注意的吗**？==由于哈希表中的每个节点都是动态分配的，使用完毕后必须一一释放，否则会造成内存泄漏，此外，当输入数组为空时，需要直接返回空数组；当内存分配失败时，则要安全地释放所有已占用的资源。
### 细节：
- **对于这道题，我是如何设计的哈希函数？**
    为了保证效率，我需要设计合适的哈希函数，考虑到元素是整数，最简单的方案是取模运算。但哈希表的大小该如何确定呢？太小会导致冲突过多，太大又会浪费空间。权衡之后，我决定将哈希表大小设为nums2长度的两倍，这样既能减少冲突概率，又不会过度消耗内存，同时，为了处理哈希冲突，每个槽位将采用链表结构，新节点插入链表头部。
### 步骤：
1. **定义哈希表节点结构**
    - 创建链表节点结构，包含三个字段：
        - `val`：存储数组元素的值
        - `index`：存储在 `nums2` 中的原始下标
        - `next`：指向下一个节点的指针
2. **初始化结果数组**
    - 分配内存空间给结果数组 `mapping`，大小为 `nums1Size`
    - 处理特殊情况：如果输入数组为空，直接返回空数组
3. **创建哈希表**
    - 计算哈希表大小
    - 分配指针数组作为哈希表，并初始化为 NULL
4. **构建哈希表（处理 nums2）**
    - 遍历 `nums2` 的每个元素：
        - 计算哈希值：`hash_key = abs(nums2[i]) % hash_size`
        - 创建新节点存储值和索引
        - 将节点插入对应槽位的链表头部
5. **构建映射关系（处理 nums1）**
    - 遍历 `nums1` 的每个元素：
        - 计算相同的哈希值
        - 在对应槽位的链表中搜索匹配节点：
            - 遍历链表，查找 `val` 等于当前 `nums1[i]` 的节点
            - 维护前驱节点指针便于删除操作
        - 找到匹配节点后：
            - 记录其 `index` 到 `mapping[i]`
            - 从链表中删除该节点
            - 释放节点内存
6. **清理资源**
    - 释放哈希表数组本身的内存
    - 返回构建好的 `mapping` 数组
下面是代码的具体实现：
![[Pasted image 20250616170122.png]]
### 知识点：
哈希表、数组