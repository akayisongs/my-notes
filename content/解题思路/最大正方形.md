![[Pasted image 20250710000745.png]]
### 思路：
当我面对这个问题时，脑海里浮现的第一个疑问是：=="如何在不使用暴力枚举的情况下高效地找到最大的全'1'正方形？" ==因为暴力解法需要检查所有可能的位置和边长，时间复杂度高达O(m³n³)，对于300×300的矩阵来说完全不可行。这让我联想到动态规划——许多矩阵问题都可以通过保存中间状态来优化，==但具体该如何定义状态呢？==
顺着这个思路，我进一步追问自己：=="动态规划的关键在于找到子问题之间的关联，那么正方形的什么特性可以被分解为子问题？" ==我意识到，正方形具有自相似性：一个边长为k的正方形，其实是由四个重叠的子正方形组成的。特别是当我以右下角为基准思考时，发现一个关键点：任何大正方形的右下角，必然依赖于其上方、左方和左上方的三个相邻位置的状态。这个洞察让我豁然开朗——或许可以用dp[i][j]表示以(i,j)为右下角的最大正方形边长。
但新的疑问随即产生：=="为什么只需要考虑这三个方向？==左上角的位置有什么特殊意义？" 我画了一个3×3的网格进行验证：假设要形成边长为3的正方形，那么(i-1,j)位置必须能形成边长为2的正方形（代表上方区域），(i,j-1)也必须能形成边长为2的正方形（代表左方区域），而(i-1,j-1)则必须能形成边长为2的正方形（代表对角线区域）。这三个条件缺一不可，因为如果左上角不满足，就会在中心位置产生缺口。这个理解让我想起了木桶原理——最终边长取决于最短的那块木板。
接下来我思考边界情况：=="对于矩阵边缘的点该如何处理？"== 显然，在第一行或第一列的点，由于没有足够的空间扩展，最大边长只能是0或1。这引出了动态规划的初始条件：当matrix[i][j]=‘1'且位于边界时，dp[i][j]直接设为1。这个设定既符合直觉，又为后续计算奠定了基础。
在构思状态转移方程时，==为什么是取三个方向的最小值再加1？==通过几个示例验证：假如三个相邻位置的dp值分别是2,1,2，那么当前点能形成的最大正方形边长就是min(2,1,2)+1=2。这对应着实际场景：虽然右侧和下方有空间，但上方只能提供1的长度，因此整体被限制。这种取最小值的操作完美捕捉了正方形的连续性要求。
实现过程中，我又想到：=="如何处理'0'位置？" ==这很简单——当遇到'0'时直接设dp[i][j]=0，因为这里不可能作为正方形的右下角。同时我意识到，在遍历过程中需要实时更新全局最大边长，否则最后还需要重新扫描整个dp数组。
### 细节：
- **为什么这个方法比暴力法高效得多？**
    关键在于它避免了重复计算——每个位置的计算都是O(1)时间，整体仅需O(mn)时间复杂度。而空间上虽然使用了额外数组，但300×300的矩阵在现代计算机上完全可行。这种用空间换时间的策略，正是动态规划的精髓所在。
- 如何处理 `matrix[i][j] == '0'` 的情况？
    一个正方形必须全部由 `'1'` 组成，`'0'` 不可能成为右下角。
    直接令 `dp[i][j] = 0`。
### 步骤：
1. 初始化处理 检查矩阵是否为空：若行数或列数为0，直接返回面积0
创建与输入矩阵相同尺寸的二维DP数组
初始化最大边长max_side = 0
2. 边界条件处理 遍历第一行元素：
若matrix[0][j] == '1'：设dp[0][j] = 1，更新max_side = max(max_side, 1)
否则：dp[0][j] = 0
遍历第一列元素：
若matrix[i][0] == '1'：设dp[i][0] = 1，更新max_side = max(max_side, 1)
否则：dp[i][0] = 0
3. 动态规划核心处理 对于非边界位置(i, j)（i≥1, j≥1）：
情况1：当前为'0' dp[i][j] = 0（不能作为正方形右下角）
情况2：当前为'1'：
检查三个相邻位置：
上方dp[i-1][j]
左方dp[i][j-1]
左上方dp[i-1][j-1]
取三者最小值：min_val = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
计算当前边长：dp[i][j] = min_val + 1
更新最大边长：max_side = max(max_side, dp[i][j])
4. 计算结果 返回最大正方形面积：max_side * max_side
下面是代码的具体实现：
![[Pasted image 20250710003150.png]]
### 知识点：
矩阵、动态规划