![[Pasted image 20250601233900.png]]
### 思路：
这道题的关键在于将目标串分为几个原串的子序列，*那么如何实现呢*？如果原串是不重复的字母，那么可以统计其目标串中哪个字母出现频次最高就是子序列的最小数量，但是并不能保证每次原串都是不重复的，所以想要将目标串分为几个子串难度是很大的，*那么如何避开将其分为子串呢*？我想到了当时学链表的合并时用到的双指针，我发现只需要原串的指针为一个循环指针，每循环一轮看目标串是否有与其相同的字符，每相同一个，目标串的指针就向后移动一位，如果某一轮之内没有相同的元素则直接返回-1，*那哪种情况计数器会加一呢*？就是在循环完一轮后，有至少一个相同元素的情况下加一，*那么如何判断每轮是否有至少一个相同元素呢*？可以设置一个标志变量，初始为0，如果有相等的则令其为1，实现的时候原串的循环指针可以直接用for循环代替。

### 步骤：
1. 首先需要得到两串的长度，用于判断内循环和外循环结束的时间；
2. 声明标记变量为0，计数器为0；
3. 外循环为目标串指针的移动，内循环为for函数进行原串的循环移动，每循环一轮看目标串是否有与其相同的字符，每相同一个，目标串的指针就向后移动一位，并将标记变量置为1；
4. 循环完一轮标记变量为1，则计数器加一，否则返回-1。
具体函数实现如下：
![[Pasted image 20250602004446.png]]

### 知识点：
字符串的元素匹配、双指针