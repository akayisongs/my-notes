![[Pasted image 20250715234601.png]]
### 思路：
既然要处理连续字符段，自然会联想到"双指针扫描"这个字符串处理的经典技巧。==但具体如何实现呢？==我设想用主指针标记当前段起点，副指针向前探索边界。这时新的问题浮现：==如何确保副指针在字符相同且长度≤9的约束下移动？==这让我意识到需要三层判断：字符是否相同（保证单字符前缀）、长度是否≤9（满足题目限制）、是否越界（保障安全性）。就像工程师设计联动装置，这三个条件必须协同工作。
在构思具体实现时，数字转换问题又跳了出来。==如何将长度数值转为字符？==灵光一现想到ASCII码中'0'到'9'的连续性——只需将长度值加上'0'的ASCII码即可。例如长度7转为字符'7'，这种字符与数字的优雅转换，犹如机械齿轮的精密咬合。但紧接着内存分配问题浮现：结果字符串可能长达原串两倍（如"a"变"1a"），这促使我在malloc时计算2n+1的空间，既避免浪费又防止溢出。
验证阶段，我模拟"aaaaaaaaaaaaaabb"的压缩流程：首轮副指针移动9位生成"9a"；第二轮移动5位生成"5a"；最后处理"bb"生成"2b"。整个过程如流水线作业般顺畅。但思考并未停止，==如果遇到"abbbbbbbbbbb"这样混合字符会怎样？==测试发现首轮取"1a"，次轮因连续10个'b'需分两段处理（9b+1b），证明算法能智能区分字符变化点。
最后审视边界情况时，单字符"a"的处理成为试金石。算法准确输出"1a"，而空字符串的假设被题目"长度≥1"的条件排除。这种层层递进的思考，如同解锁装置的保护壳：先理解核心规则（长度≤9的分段压缩），再设计扫描机制（双指针的三重约束），接着解决技术细节（数字转换与内存分配），最后验证各类场景。
### 细节：
- **如何将长度数值转换为字符？**
利用ASCII码特性：字符'0'-'9'的编码连续。通过`'0' + len`实现转换（如长度7 → `'0'+7 = '7'`）。这是数字与字符间最高效的转换方式。
### 步骤：
1. **初始化处理环境**
    - 获取输入字符串长度 `n`
    - 为结果字符串分配内存空间（大小为 `2*n + 1`）
    - 初始化结果字符串索引 `index = 0` 和字符指针 `i = 0`
2. **遍历输入字符串**
    - 当 `i < n` 时循环处理：  
        a. 获取当前起始字符 `c = word[i]`  
        b. 设置扫描指针 `j = i` 准备检测连续字符段
3. **扫描连续字符段**
    - 在以下条件同时满足时移动 `j`：
        - `j < n`（未越界）
        - `word[j] == c`（字符相同）
        - `j - i < 9`（长度不超过9）
    - 最终得到连续段长度 `len = j - i`
4. **构建压缩结果**
    - 将长度转换为字符：`comp[index++] = '0' + len`
    - 追加当前字符：`comp[index++] = c`
5. **移动到下一段**
    - 更新指针位置：`i = j`（跳过已处理段）
    - 自动处理字符变化点（当遇到新字符时）
6. **结束处理**
    - 循环结束后添加字符串终止符：`comp[index] = '\0'`
    - 返回结果字符串指针
下面是代码的具体实现：
![[Pasted image 20250716001931.png]]
### 知识点：
字符串