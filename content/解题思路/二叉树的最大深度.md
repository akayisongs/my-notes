![[Pasted image 20250612000726.png]]
### 思路：
要计算二叉树的最大深度，首先要知道**什么是最大深度**？答案是从根节点到最远叶子节点的路径上的节点总数。那么**如何高效计算这个深度呢**？考虑到二叉树本身具有递归结构，每个节点的左右子树又是新的二叉树，递归自然是比较好的解决方案。那么先想**递归的终止条件是什么呢**？当遇到空节点时返回深度0，这既是计算的起点也是终点。**对于非空节点该如何处理**？我们先递归计算左子树深度，再计算右子树深度，然后取二者中的较大值并加1，这个加1代表当前节点自身的深度贡献。**为什么取较大值**？因为最大深度取决于更深的那棵子树，如同选择更长的路径延伸。**这种方法为何高效**？它采用后序遍历顺序，确保处理节点时子树深度信息已就绪，时间复杂度为O(n)，每个节点仅访问一次。**递归过程会重复计算吗**？不会，递归沿着树结构自然展开，每个节点只处理一次。**它能处理特殊情况吗**？完全可以，当某子树为空时，其深度0会参与比较，确保单子树情况结果正确。最后，**这种思路还有何优势**？*它体现了分治思想的核心：将大问题分解为相似子问题，通过解决子问题构建整体解决方案，且稍加修改就能解决最小深度、平衡判断等衍生问题。*
### 细节：
- **为什么选择递归方法来解决这个问题？**
    递归是处理树形结构的自然选择，因为二叉树本身就是一个递归定义的数据结构——每个节点的左右子树又是二叉树。递归方法可以将大问题分解为小问题：要计算整棵树的深度，只需要先计算左右子树的深度，然后取较大值加1即可。***这种方法避免了复杂的迭代过程，代码更加简洁直观。***
### 步骤：
1. 先判断当前节点是否为空，若为空则返回深度0，这是递归的基准条件；
2. 递归计算左子树的最大深度，这个过程会一直深入到左子树的最底层节点，逐层返回深度信息。同时，递归计算右子树的最大深度，同样会遍历右子树的所有分支；
3. 较左右子树的深度值，选取其中较大的一个，这决定了当前节点所在分支的最大路径深度；
4. 将选取的较大深度值加上1，这个"加1"代表当前节点自身的深度贡献，形成完整的深度计算结果。当递归返回到根节点时，我们便得到了整棵树的最大深度。
下面是代码的具体实现：
![[Pasted image 20250612003157.png]]
### 知识点：
二叉树、递归