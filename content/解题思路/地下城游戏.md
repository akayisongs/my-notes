![[Pasted image 20250706194901.png]]
### 思路：
这道题问题核心在于如何规划路径，确保骑士始终有足够的生命值抵达终点。但路径选择会影响健康值变化，正向思考似乎很复杂，当我初次思考解法时，很自然地联想到用贪心策略——每步选择当前收益最高的方向：若右边房间加血就向右走，若下方扣血就避开。但深入推演后发现问题没那么简单，因为骑士的生存条件具有全局性约束：健康值必须全程保持正数，而路径上的正负效果会相互抵消，形成复杂的动态平衡。例如某个房间虽提供大量加血，但到达它需要先承受高风险扣血，贪心算法因短视可能直接拒绝这条路径，却不知这正是全局最优解的关键跳板；反之，贪心偏爱的平缓路径可能因终点致命扣血而前功尽弃，而这道题如果从起点出发，每条路径的健康值变化像是一条波动曲线，我需要同时跟踪初始值和路径上的最低健康值，状态会变得非常臃肿，==有没有更简洁的视角？==这时我想到了动态规划中常用的逆向思维。既然终点是固定的，何不从终点反向推回起点？这样就能避免记录路径波动。假设骑士站在某个房间，我需要计算他从这里出发所需的最小初始健康值。这个定义让我豁然开朗，因为每个房间的状态只依赖于后续路径，而不必考虑前面的复杂波动。接着，==终点房间的状态如何确定？==如果公主所在的房间值是x，骑士进入时健康值h需满足h + x ≥ 1，否则他会立即死亡。因此初始值至少要是max(1, 1 - x)。若x为负（比如-5），则需6点健康值；若x为正（比如10），1点就够了。
然后我推演到其他房间：骑士向右或向下移动时，==如何传递健康值需求？==假设已知右边和下边房间所需的最小初始值，骑士会选择要求更低的路径。但关键点在于：离开当前房间时的健康值，必须满足下一个房间的初始值要求，例如当前房间值d，进入健康值h，离开时变为h + d，这个值必须≥下一个房间的dp值。因此得到核心公式：h ≥ next_dp - d。同时h本身不能低于1，所以最终h = max(1, next_dp - d)。想到这里，==有哪些边界问题需要解决的吗？==在网格边缘，骑士只有一个移动方向。比如最后一行只能向右走，那么状态转移时只需考虑右侧房间的值。这让我在代码中通过条件判断就能优雅处理，避免数组越界。
最后，回忆整个思路的突破点：正向思考时，路径上的正负值交错像一团乱麻；但逆向推导让每个房间的状态变得独立且清晰。这种“以终为始”的视角转换，正是动态规划的精华所在。通过将问题分解为终点到起点的递推链，用数学公式表达房间间的健康值传递，最终高效解决了这个看似复杂的路径规划问题。
### 细节：
- **这道题到底为何不能使用贪心算法来解决？**
    首先，健康值需求具有非线性阈值效应，初始值必须覆盖整条路径的最低健康点，而非路径总和；其次，路径选择产生蝴蝶效应：一个房间的扣血是否危险，完全取决于后续能否补充。若后续有加血房间，当前扣血反而是投资而非风险，这种跨房间的补偿机制彻底破坏了贪心的局部独立性假设；最后，健康值变化存在方向不对称性：加血效果可被扣血抵消，但扣血造成的死亡不可逆，这像走在钢丝上，任何一步失误都会导致全局失败，贪心算法却只盯着脚下一步的绳索晃动。
### 步骤：
1. **初始化网格参数**：首先获取地牢网格的行数`m`和列数`n`，作为动态规划的基础维度，若网格为空则直接返回健康值1（最小生存需求）；
2. **分配动态规划表**：创建一个二维数组`dp`，大小与地牢网格相同，用于存储从每个房间出发到达终点所需的最小初始健康值。这是动态规划的核心数据结构；
3. **初始化终点状态**：设置右下角终点房间的状态值：
    - 计算`1 - dungeon[m-1][n-1]`（抵消终点房间影响所需健康值）
    - 与1取最大值：若结果为负则取1（保证健康值不低于生存阈值）；
4. **反向遍历网格**：从网格右下角开始向左上方遍历：
    - 外层循环：从最后一行向上遍历到第一行(`i = m-1 → 0`)
    - 内层循环：从最后一列向左遍历到第一列(`j = n-1 → 0`)
    - 跳过已处理的终点房间；
5. **确定移动方向**：对于每个房间`(i, j)`：
    - 检查能否向右移动：若不在最后一列，获取右侧房间的`dp[i][j+1]`
    - 检查能否向下移动：若不在最后一行，获取下方房间的`dp[i+1][j]`
    - 将不可达方向的值设为最大整数(INT_MAX)，确保不被选中；
6. **计算最小后续需求**：取右侧和下方房间需求值的较小者`min_next`，代表选择最优路径方向
7. **计算当前房间需求**：
    - 计算`min_next - dungeon[i][j]`（抵消当前房间影响）
    - 与1取最大值：确保健康值不低于生存阈值
    - 公式：`dp[i][j] = max(1, min_next - dungeon[i][j])`
8. **处理边界情况**：
    - 最后一行房间：只考虑右侧移动（下方设为INT_MAX）
    - 最后一列房间：只考虑下方移动（右侧设为INT_MAX）
    - 单房间网格：直接处理为终点情况
9. **返回起点结果**：遍历完成后，`dp[0][0]`即为骑士在起点所需的最小初始健康值
10. **释放内存资源**：依次释放动态规划表每行的内存，最后释放表结构本身，防止内存泄漏
![[Pasted image 20250820093102.png]]
### 知识点：
动态规划、矩阵
