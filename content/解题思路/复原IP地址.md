![[Pasted image 20250715005505.png]]
### 思路：
这道题地址必须由四个整数组成，每个整数在0到255之间；整数间用点分隔；每个整数不能有前导零（除非本身就是单个"0"）；且必须用完字符串所有字符且顺序不变。例如"192.168.1.1"有效，但"192.168@1.1"因非法字符无效，"0.011.255.245"因前导零无效。这些规则像一把尺子，后续所有方案都必须通过它的测量。
接着我思考：==如何系统化地寻找所有可能的分割方案？== 由于字符顺序固定且需插入三个点，我意识到本质是在字符串中选三个分割点，将其分为四段。但盲目枚举所有组合效率太低——字符串长达20字符时，组合数可能爆炸。于是，我结合IP段长度特性（每段仅1-3字符）优化思路：用三层循环分别控制第一、二、三段的结束位置。第一段长度在1-3之间选择，并确保剩余字符至少能分成三段；基于第一段位置，第二段同样在1-3字符内滑动，同时剩余需足够分两段；第三段则受限于第四段长度也需为1-3。例如处理"101023"时，第一段可能取"1"、"10"或"101"；若取"10"，第二段可试"1"（得"10.1"），剩余"023"再分两段。这种分步推进如同在迷宫中谨慎探索路径，每步都预留后续空间。确定枚举框架后，我追问：==如何验证每段数字的合法性？== 即使长度符合，还需双重验证：一是前导零检查——若段长大于1且首字符为'0'（如"01"），立即淘汰；二是数值范围——通过临时复制子串并转换为整数，判断是否在0-255内。例如分割"0000"时，若尝试"00.0.0.0"会因"00"含前导零失败，但分成四个"0"则合法。这里我联想到经验：数值转换需注意边界，如"255"有效但"256"越界；同时，处理全零字符串时需区分"0"（有效）和"00"（无效）的微妙差别。
随后，我反思：==有哪些易忽略的边界情况？== 首要的是字符串总长——若小于4或大于12（如"123"或"1234567890123"），直接返回空结果，因为分段必然失败。其次，在循环中需严格检查剩余字符是否足够：例如当第一段取3字符后，剩余9字符时，第二段若再取3字符，剩余6字符仍可分成两段；但若剩余仅2字符，则必须终止循环。这让我想起"101023"的例子：当第一段取"101"（3字符），剩余"023"需分三段，此时第二段只能取"0"（1字符），剩余"23"分两段，形成"101.0.2.3"。
最后，我综合思考：==如何高效构建并存储结果？ ==每找到一组有效分割（如"255"、"255"、"11"、"135"），需在字符间插入点号生成IP字符串。在C中需动态分配内存，将四段复制到新数组并添加分隔符。例如对"25525511135"，生成"255.255.11.135"后存入结果列表。这里我预估最大结果数（如100）预分配空间，避免反复分配开销。
### 细节：
- **如何高效构造结果并管理内存**？
    对于每个有效分段方案：动态分配内存构建IP字符串（长度=原串长+3个点+1个结束符）；分段复制字符并在段间插入点号；将生成的IP加入结果数组。结果数组使用realloc动态扩展，最后返回时需包含有效IP数量。整个过程结束后，需要逐层释放内存防止泄漏，这种内存管理策略既高效又安全。
### 步骤：
1. 首先进行输入验证，检查字符串长度是否在有效范围（4-12字符），若长度小于4或大于12则直接返回空结果，因为无法形成有效IP；
2. 接着初始化结果数组和计数器，准备收集有效IP地址。然后通过三层嵌套循环枚举所有可能的分割点：第一层循环确定第一个点号的位置（第一段结束索引i，范围1-3字符），第二层循环在第一段基础上确定第二个点号位置（第二段结束索引j，范围i+1到i+3），第三层循环在前两段基础上确定第三个点号位置（第三段结束索引k，范围j+1到j+3），这样将字符串划分为四段；
3. 对每个候选分段方案的四段子串，依次执行三重检查：第一检查长度是否合法（每段1-3字符），第二检查前导零（长度大于1时首字符不能是'0'），第三检查数值范围（转换为整数后必须在0-255之间）；
4. 对于验证通过的方案，我们动态分配内存构建IP字符串：先复制第一段字符到缓冲区，添加点号；接着复制第二段字符并加点；然后复制第三段字符并加点；最后复制第四段字符，添加字符串结束符，形成完整的"a.b.c.d"格式；
5. 将构造好的IP地址添加到结果集：扩展结果数组内存空间，存入新生成的IP字符串指针。在枚举过程中，如果发现新扩展的边界已覆盖整个字符串，可提前终止后续循环以优化性能。

下面是代码的具体实现：
![[Pasted image 20250621000245.png]]
### 知识点：
字符串、回溯