![[Pasted image 20250628202257.png]]
### 思路：
这道题目要求要到达第n阶台阶，那么最后一步要么是从第n-1阶跨1阶，要么是从第n-2阶跨2阶。这个关键洞察立刻将问题拆解为两个子问题：到达n-1阶和n-2阶的方法数之和。这种分解方式让人联想到数学中的递归思想，但很快又产生新的疑问，==直接递归是否高效？==仔细思考后发现，递归会导致大量重复计算。比如计算n=5时需要n=4和n=3的结果，而计算n=4时又需要n=3和n=2，这里的n=3就被重复计算了。随着台阶数增加，这种重复会呈指数级增长，效率极低。于是很自然地转向动态规划的思路：==能否存储中间结果避免重复？== 最初想到用数组存储每阶台阶的方法数，这样时间复杂度降到O(n)，但空间复杂度仍是O(n)。这时注意到每个状态只依赖前两个状态，这引出了核心优化思路：==能否用更少空间存储状态？ ==实际上只需要三个变量：prev1记录前1阶方法数，prev2记录前2阶方法数，current计算当前阶方法数。每次循环就像踏上一级新台阶：current=prev1+prev2计算出新方法数，然后prev1和prev2向前滚动更新，整个过程只需遍历一次，空间复杂度优化到O(1)，最后要解决边界情况：==特殊台阶如何处理？== 当n=0时无意义返回0；n=1时只有1种方法；n=2时有两种方法。从n=3开始循环计算，结果恰好形成斐波那契数列。
### 细节：
- **为什么不是组合数学问题？**
    虽然看似排列组合，但不同顺序算不同方法（如1+2和2+1是两种）且依赖子问题解而非直接计算组合数，而动态规划天然处理了顺序问题。
### 步骤：
1. 检查台阶数 n 的特殊情况，若 n = 0：返回 0（无意义情况）；若 n = 1：返回 1（只有1种方式：爬1阶）；若 n = 2：返回 2（两种方式：1+1 或 2）；
2. 设置两个关键状值：`prev1 = 1`：表示到达第1阶的方法数，`prev2 = 2`：表示到达第2阶的方法数；
3. 从第3阶台阶开始，逐阶向上计算到达该阶的方法数，对于当前阶数i，其方法数由前两阶的方法数决定，即到达第i-1阶的方法数（存储在prev2变量中）加上到达第i-2阶的方法数（存储在prev1变量中），计算得到当前阶数的方法数后，立即更新状态变量：将prev1的值更新为原先prev2的值（即前移一阶），再将prev2的值更新为刚计算出的当前阶方法数；
4. 循环结束后，prev2 存储最终结果（第n阶方法数），返回 prev2 的值。
下面是代码的具体实现：
![[Pasted image 20250629000641.png]]
### 知识点：
递归、动态规划