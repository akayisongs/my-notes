![[Pasted image 20250610195534.png]]
### 思路：
这道题关键需要先解决如何得知其是否为环形链表这个问题，由于该题目没有说每个节点的值一定是不一样的所以我们不能通过记录链表中元素值来判断，那么有什么比较好的方法吗？我想到了可以设置一个哨岗指针和一个遍历指针来实现这个问题，如果哨岗指针遇到两次遍历指针则可以确定其有环，但是由于进入环的位置不确定，我们很难找到一个静态哨岗指针的位置（其实也可以设置在该链表尾部，但由于这么做对寻找其环的进入点没有帮助，则弃用了），那我们应该如何解决这个问题呢？我想到了可以使用双动态指针的方法，并且两指针设置一个速度差，如果有环，则二者一定会在某轮相遇，为了简便，我们需要考虑如何让慢指针在第一轮遍历即与快指针相遇？可以发现如果快指针速度如果慢于慢指针速度的两倍时，就会出现两者相遇时，慢指针已经循环超过一轮了，那么我们可以令快指针速度为一次两个单位，慢指针遍历速度为一次一个单位，这样我们会发现两者相遇一定是在快指针循环完一轮后的某轮中，慢指针第一轮还在遍历时，那两指针相遇时该如何计算其进入循环的位置呢？这时我们可以设头节点到环入口距离为 A，环入口到相遇点距离为 B，相遇点到环入口剩余距离为 C，可以知道慢指针路程为A + B，快指针路程为A + B + K*(B+C)（K为整数），由于速度为两倍关系，时间相等，可得出路程关系为2(A+B) = A+B + K*(B+C)，可以得到A = (K-1)(B+C) + C，这时可以发现如果将其中一个指针重置回头节点并将两者速度都设为1，那么两者相遇点一定为环的入口，为什么呢？因为头节点到环入口的长度恰为整数倍环长加上之前相遇时继续往后遍历到环入口的长度，所以二者一定相遇于环入口。
### 步骤：
1. 初始化指针，创建两个指针 `slow` 和 `fast`，初始时均指向链表头节点 `head`；
2. 检测环是否存在，慢指针 `slow` 每次移动一步，快指针 `fast` 每次移动两步，当两指针相遇时（`slow == fast`），说明链表存在环，若 `fast` 遇到 `NULL` 或 `fast->next` 为 `NULL`，则链表无环，返回 `NULL`；
3. 定位环入口，将慢指针 `slow` 重置回链表头节点 `head`，保持快指针 `fast` 位于相遇点，两个指针以相同速度（每次一步）同步移动，当两指针再次相遇时，该位置即为环的入口节点。
下面是代码的具体实现：
![[Pasted image 20250610210043.png]]
### 知识点：
双指针、链表