![[Pasted image 20250623203739.png]]
### 思路：
这道题关键是要得到两数组正序合并后的中间序号的元素，**如何将两数组正序合并为一个数组呢**？可以使用两个指针分别指向两数组的第一个元素，每次进行比较，将二者中更小的元素放入新数组中，然后指向更小元素的指针再向后移，直至将两个数组元素都放入新数组，但是这样的时间效率将来到O（n+m），**那么如何提高算法的时间效率呢**？我们可以通过只比较到中间位数元素后终止遍历来剪枝，但其时间复杂度还是很难达到log级别，重新审视这个问题，对于合并后的有序数组，**中位数处于什么位置**？当总元素个数为奇数时，它是第 (m+n+1)/2 个元素；当为偶数时，它是第 (m+n)/2 和 (m+n)/2+1 个元素的平均值，那么问题可以转化为：**如何在两个有序数组中高效地找到第 k 小的元素**？如果能解决这个问题，中位数问题就迎刃而解了，然后，我考虑如何在不实际合并数组的情况下找到第 k 小的元素。由于两个数组都是有序的，**能否利用二分查找的思想呢**？具体来说，**我是否可以通过比较两个数组中的特定元素**，**来排除掉不可能包含第 k 小元素的部分**？例如，如果我取数组 A 的前 k/2 个元素和数组 B 的前 k/2 个元素进行比较，会发生什么？如果 A 的第 k/2 个元素小于 B 的第 k/2 个元素，那么 A 的前 k/2 个元素肯定都小于第 k 小元素，因此可以安全地排除它们。这样，问题规模就缩小了 k/2，接着，我们需要处理实现中的细节问题，**当某个数组长度小于 k/2 时该怎么办**？这时我应该取该数组的全部元素进行比较。而如果 k 减小到 1，问题就变得很简单：只需取两个数组首元素中的较小值。此外，当一个数组为空时，直接返回另一个数组的第 k 个元素即可，最终，在找到正确的划分位置后，根据总长度的奇偶性返回单个中位数或两个中间值的平均数，就能完美解决这个问题。
### 细节：
- **具体编码时还有什么可以优化的吗**？
    在划分数组时，我们可以始终选择较短的数组作为二分对象，这样做可以最大限度地减少搜索范围，因为二分查找的时间复杂度取决于较小数组的长度，而且，通过合理设置边界条件（如使用 INT_MIN 和 INT_MAX 处理数组边界），可以确保比较操作不会越界。
### 步骤：
1. 确保nums1是较短的数组（如果nums1长度大于nums2，则交换两个数组），计算总元素个数：total = m + n，确定左半部分应有的元素个数：half = (total + 1) / 2；
2. 设置left = 0，right = nums1长度（在较短的数组上进行二分），准备处理边界情况的特殊值：INT_MIN和INT_MAX；
3. 检查短数组左半最大值是否小于等于长数组右半最小值，同时长数组左半最大值是否小于等于短数组右半最小值；
4. 如果这两个条件同时满足，说明找到了正确划分：当total为奇数时，中位数就是两个左半最大值中的较大者；当total为偶数时，中位数则是（左半最大值较大者 + 右半最小值较小者）的平均值；
5. 如果条件不满足，则调整二分边界：当短数组左半值过大时，将right设为i-1；当短数组左半值过小时，将left设为i+1；
6. 这个过程持续循环，直到找到满足条件的划分点。
下面是代码的具体实现：
![[Pasted image 20250623215528.png]]
### 知识点：
二分查找、数组