![[Pasted image 20250816164843.png]]
### 思路：
这道题比较直观的方法 就是将将输入的数的每一位依次进行翻转，再将每一次翻转一位后的数记录下来，最后再将各个数进行相互对比，在执行这种算法的过程中，==需要注意一些什么呢==？比如由于6和9掉换比较频繁，可以将其封装成一个函数；用一个循环即可实现遍历修改加上存储每次修改完成的数据，存储的时候可以选用数组，==那么数组的大小如何确定呢==？由于题目给定的条件显示最大不超过五位，那我们定义五个单位即可，最后还要通过循环遍历数组，最终比较大小，但实际这样的算法看上去太直接，仅仅是因为这道题相对来说要求较低，他的资源占用也不算高，但是显然这道题是在考察我们对数字操作的敏感度。题目要求给定一个只由 6 和 9 构成的正整数，我们最多只能翻转一位，把 6 变成 9，或者把 9 变成 6，从而得到一个尽可能大的数。**那么，关键问题来了：==我们该翻转哪一位呢？==**
第一反应是：==是不是每一位都要试一下==？比如给定 9669，我们可以尝试把第一位变 6 得到 6669，把第二位变 9 得到 9969，把第三位变 9 得到 9699，最后一位变 6 得到 9666。结果确实可以找到最大值 9969。但这样做是不是太麻烦了？
再换个角度想：数字的大小主要由高位决定。既然目标是让数尽可能大，那么==是不是只需要找到最靠前的 6，把它改成 9 就行了？==答案是肯定的。因为一旦高位的 6 变成 9，其提升的幅度一定大于后面任何一位的变化。比如 9669，把第二位的 6 变成 9，直接就得到 9969，这是全局最大解。
那么问题又来了：==如果数字里根本没有 6，全是 9 怎么办？==这时候其实就什么都不用做了，因为数字本身已经是最大值。比如 9999，不论怎么翻转，都会变小。
这样我们就得到了最简洁的策略：**从左到右扫描，遇到第一个 6 就改成 9，然后结束**。实现上可以有两种方式：一种是把数字转成字符串，方便替换；另一种是用数学运算，从高位到低位检查，找到第一个 6 的位置直接加上 3×10^pos。两者复杂度其实都是 O(d)，而 d ≤ 5，可以看作常数时间。
这道题的核心在于发现规律：最大化结果取决于最高位的变化。通过不断自问自答，我们会发现题目并不需要穷举所有可能，而是一次扫描就能解决。
### 细节：
- **如何才能使结果最大化？**
优先修改最高位的数字，因为高位对整体数值影响最大。
- **需要遍历所有可能的修改情况吗？**
不需要。只要找到第一个 `6` 并修改即可，不必尝试所有情况。
### 步骤：
- **初始化变量**
    - 定义 `temp = num` 用于逐位扫描；
    - 定义 `pos = -1`，记录最左边的 6 的位置（从右往左数）；
    - 定义计数器 `i = 0`，表示当前正在扫描的位数。
- **逐位扫描数字**
    - 当 `temp > 0` 时循环：
        - 取出当前最低位：`digit = temp % 10`；
        - 若 `digit == 6`，则更新 `pos = i`；
        - 去掉最低位：`temp = temp / 10`；
        - 计数器自增：`i++`。
- **判断是否存在 6**
    - 如果 `pos == -1`：说明数字中没有 6，直接返回原数 `num`；
    - 否则进入下一步。
- **修改对应位置的数字**
    - 计算需要增加的值：`delta = 3 * 10^pos`；
    - 更新结果：`num = num + delta`。
- **返回结果**
    - 输出最终的最大数字 `num`。
下面是代码的具体实现：
![[Pasted image 20250816195425.png]]
### 知识点：
贪心、数学