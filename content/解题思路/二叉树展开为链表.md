![[Pasted image 20250708205219.png]]
### 思路：
我们在数据结构的学习中，曾经遇到过二叉树的三种遍历方式，而这道题就要求我们将二叉树以先序遍历的顺序展开为单链表，那么我们首先需要回忆：==如何实现二叉树的先序遍历？==很简单，只需要将遍历节点值放在递归遍历左子树和右子树前面即可，这道题目又要求节点还是以原来二叉树的节点类型，将二叉树转化为只有右子树的二叉树，那么我想到：==如果不申请新的存储空间用于存放新二叉树，那么它的空间复杂度是不是会更低呢？==如果要达到这样的要求，那么我们的关键问题就在于解决：==如何将父子节点之间的指针更改到正确的位置上？==首先，我自问：既然先序遍历的顺序是根节点、左子树、右子树，而展开后的单链表要求右指针串联所有节点，左指针全为空，我能否直接在原树上操作，==避免递归栈或额外数组的空间开销呢？==是的，这很诱人，因为递归虽然直观，但空间复杂度是O(n)，在树很大时可能成为瓶颈，那么如何解决呢？我们可以意识到可以通过栈来实现二叉树的展开，那么我立即自问：==栈这种数据结构如何与二叉树的先序遍历产生联系？==回忆当初学习二叉树遍历时，递归实现虽然简洁，但本质上是编译器在幕后维护了一个调用栈。那么，显式地使用栈来模拟递归过程，不正是解决这个问题的自然思路吗？这个想法让我感到兴奋，因为它既能保留递归思维的直观性，又能避免递归调用的系统开销。于是我开始设想具体实现：首先将根节点入栈，然后在循环中不断弹出节点进行处理——这确实符合先序遍历从根节点开始的特性。
不过，我马上又陷入新的困惑：==如何处理节点的连接关系？==自问：当我们从栈中弹出一个节点后，它的左右子节点应该以什么顺序入栈？这里我想到了先序遍历的"根-左-右"特性，但栈是后进先出的结构。经过反复推演，终于明白：要让左子树先被处理，就必须让右子节点先入栈，左子节点后入栈。这样当左子节点位于栈顶时，它就会优先被弹出处理。这个发现让我豁然开朗，原来栈的逆序特性在这里反而成为优势！
紧接着，我面临更关键的问题：==如何建立链表连接？==自问：==当前节点与前一个节点之间怎样建立关系？==这需要引入一个辅助指针pre。当处理当前节点时，如果pre不为空，就将pre的右指针指向当前节点，同时将pre的左指针置空——这样链表关系就建立起来了。但这里有个精妙之处：pre总是在动态更新，始终指向链表的末尾。这个设计让我联想到链表操作中的尾指针技巧，不同的是现在要处理的是树结构。在测试这个想法时，我发现当处理根节点时pre为空，这很合理，因为链表头不需要前驱。实现过程中，我又意识到一个潜在陷阱：==节点入栈后指针会被修改吗？自问：在将子节点入栈后，如果立即修改当前节点的左右指针，会不会破坏树结构？==经过仔细推敲，我发现根本不需要提前修改——我们只需要在节点出栈时处理连接关系，而入栈时节点指针保持原样即可。这个认知很重要，它意味着我们可以在不破坏原始结构的情况下完成入栈操作，等到节点弹出时再安全地修改指针。这种"惰性修改"的策略既安全又高效。
当基本逻辑理清后，我开始思考边界情况：==空树怎么办？单节点树怎么处理？叶子节点需要特殊处理吗？==而栈实现天然支持这些边界：空树直接返回；单节点树在循环中处理一次后结束；叶子节点没有子节点可入栈，自然成为链表末尾。更妙的是，==最后一个节点需要特殊处理吗？==在循环结束后，我只需要确保其左指针置空即可，因为右指针在入栈时已确定为null。
### 细节：
- **如何确保展开后的链表顺序与先序遍历完全一致？**
    关键在于栈的操作顺序。我们按照"右子节点先入栈，左子节点后入栈"的原则，这样出栈顺序就是"左子节点先出，右子节点后出"，与先序遍历的"根-左-右"顺序完美匹配。这种LIFO（后进先出）特性正是栈的核心优势。
### 步骤：
**1. 初始化数据结构**
- 创建空栈并压入根节点（若根节点非空）
- 初始化前驱节点指针 `pre` 为 `NULL`（用于记录链表中的前一个节点）
**2. 栈循环处理（核心步骤）**
- 当栈非空时循环执行以下操作：
    a. **弹出当前节点**：取出栈顶节点作为当前处理节点 `cur`  
    b. **连接链表**：
    - 若 `pre` 非空，将 `pre` 的右指针指向当前节点 `cur`
    - 将 `pre` 的左指针置空（断开原树结构）  
    c. **按序压入子节点**：
    - 先压入右子节点（若存在）
    - 再压入左子节点（若存在）
    - _（此顺序保证左子树先出栈处理）_  
    d. **更新前驱节点**：将 `pre` 指向当前节点 `cur`
**3. 终止处理**
- 循环结束后，`pre` 指向链表最后一个节点
- 将 `pre` 的左指针置空（确保链表结尾符合要求）
- 释放栈占用的内存空间
下面是代码的具体实现：
![[Pasted image 20250709010235.png]]
### 知识点：
栈、二叉树的先序遍历