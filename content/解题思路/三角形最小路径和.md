![[Pasted image 20250630201352.png]]
### 思路：
题目规定每次只能移动到下一行相邻的节点，这让我联想到现实中下楼梯时只能跨到相邻台阶的场景。那么，==最直观的解法是否就是穷举所有路径？==但当我计算路径数量时发现，对于n层三角形会有2^(n-1)条路径——这意味着当n较大时，计算量会指数级增长，显然不可行。这时，我回想起动态规划的核心思想：避免重复计算子问题。那么，==这个问题的子问题结构是什么？==
仔细观察三角形结构，我发现一个关键特征：每个位置的最小路径和只取决于它正下方和右下方的两个位置。这让我想到，如果从底部开始逆向计算，就能避免复杂的边界判断。于是我问自己：==为什么不采用自底向上的策略呢？==在常规思维中，我们习惯从起点到终点思考路径，但这里逆向计算反而更简单。比如在示例中，倒数第二行的数字6，其最小路径就是6加上下一行相邻位置4和1中的较小值。这种"每个局部最优解构成全局最优解"的特性，正是动态规划适用的典型场景。
接下来，我考虑具体实现：需要存储每个位置到底部的最小路径和，但若用二维数组会占用O(n²)空间。==能否优化？==我意识到计算上一层时只需要下一层的结果，因此只需要一个一维数组存储当前层的计算结果。比如计算第三层时，用dp数组存储第四层[4,1,8,3]；计算第二层时，dp更新为[4+min(6,5), 1+min(5,7), ...]——这样空间复杂度就降到O(n)。这让我联想到"滚动数组"的优化技巧，在背包问题中也有类似应用。
在实现过程中，我特别关注边界处理：当三角形只有一行时，直接返回该元素值；初始化时dp数组就是最后一行本身。测试示例2的[-10]时，这种处理方式直接得到正确结果-10，验证了边界处理的正确性。此外，内层循环中列索引从0到i的设计，完美匹配了三角形每行元素数量递增的特性。
最终实现时，从倒数第二行开始向上遍历，每行从左到右更新dp值：dp[j] = triangle[i][j] + min(dp[j], dp[j+1])。这个简洁的公式背后蕴含着深刻的数学原理：贝尔曼最优性方程。当处理到顶层时，dp[0]就是全局最优解。在示例1中，这个算法逐步计算出：第三层[7,6,10]，第二层[9,10]，最终得到11，与手动计算结果一致。
整个过程让我深刻体会到：逆向思维在算法设计中往往能化繁为简。通过自底向上的动态规划，将看似复杂的路径选择问题转化为优雅的迭代计算。
### 细节：
- **二维DP数组是否必要**？
    由于计算第i行时只依赖i+1行的数据，可以仅用一维数组存储当前行状态。从最后一行开始初始化dp数组，每次更新时覆盖当前行：dp[j] = triangle[i][j] + min(dp[j], dp[j+1])。这样空间复杂度从O(n²)降为O(n)，如同在攀登时逐步丢弃不必要的装备，只保留最关键的行囊。
### 步骤：
1. 初始化状态数组：创建一个与三角形最后一行大小相同的数组`dp`，将其初始化为三角形的最后一行。这一步相当于设置从底部各点出发的最小路径和（即各点自身的值）；
2. 从三角形的倒数第二行开始向上遍历（行索引从大到小）：
    - 对于当前行的每个位置`j`（从左到右）
    - 计算`dp[j] = 当前节点值 + min(下一行同列值, 下一行下一列值)`
    - 更新后的`dp[j]`表示从该位置到底部的最小路径和
3. 在每行计算完成后，`dp`数组的前半部分会被更新为当前行各位置到底部的最小路径和。未更新的后半部分不再使用，因为上一行的计算只需要当前行长度的数据；
4. **处理顶层节点**  
    当遍历到最顶层时：
    - 计算`dp[0] = 顶层节点值 + min(dp[0], dp[1])`
    - 此时`dp[0]`即为从顶点到底部的最小路径和
5. **返回最终结果**  
    完成所有层的计算后，直接返回`dp[0]`作为最终结果
下面是代码的具体实现：
![[Pasted image 20250630210219.png]]
### 知识点：
数组、动态规划