![[Pasted image 20250709010630.png]]
### 思路：
首先我意识到，边界条件暗示着数组首尾元素也可能是峰值，这打破了常规的搜索思维定式，于是我开始思考：==是否可以利用这个特性设计一种更高效的算法？==随着思考深入，我产生了一个核心问题：==如何确定峰值存在的区域范围？==考虑到峰值是局部最大值，我联想到山脉的地形特征——当你站在某个位置时，如果右侧是下坡路，说明你很可能就在山顶或山顶左侧；如果右侧是上坡路，则山顶一定在右侧方向。这个自然界的类比让我豁然开朗：通过比较当前位置与右侧邻居的关系，就能确定峰值所在的半区！这种局部判断不需要全局有序性，正是二分查找可以发挥作用的关键。
但紧接着我又陷入新的困惑：==为什么这种方法不会错过真正的峰值？==为了验证这点，我在脑海中构建了几个极端场景。假设整个数组是严格递增的，根据算法我们会不断向右移动，最终停在最后一个元素——而根据边界条件，它确实是一个峰值。反之如果是严格递减，则会停在第一个元素。更复杂的场景如[1,3,2]中，算法会在第一次比较时发现3>2，从而锁定左侧区间找到峰值。这些思维实验让我确信：无论何种分布，总存在至少一个峰值满足二分条件。
在实现细节上，我反复推敲边界处理：==当区间缩小到两个元素时会发生什么？==比如[1,2]这个案例，mid=0位置比较1<2，左指针会移动到1位置，此时左右指针重合结束循环，正确返回峰值索引1。而当区间为三个元素时，如[3,1,2]，mid=1位置比较1<2，左指针移动到2位置，最终返回正确峰值索引2。这些细节推演让我确信二分点计算和指针移动的设置是严谨的。
更深层次地，我开始思考这种方法的本质优势。传统遍历需要O(n)时间，而二分查找每次折半的特性天然满足O(log n)要求。更重要的是，这种方法不依赖全局单调性，而是利用局部特征决策——这正是计算机科学中"分治策略"的精妙体现。
### 细节：
- 是什么性质让我们能每次都舍弃一半空间？
    是数组中任意一点的 **“坡度”** 性质。对于数组中间的任意一个元素 `nums[mid]`，我们通过比较它和它的右邻居 `nums[mid+1]`，可以判断出当前位置的“坡度”：
1. **上坡 (`nums[mid] < nums[mid+1]`)**：说明右边有更高的点，那么峰值一定在右半部分。
    
2. **下坡 (`nums[mid] > nums[mid+1]`)**：说明 `mid` 本身就是一个峰值，或者峰值在它的左半部分。
- **如何确保不会错过峰值？**
  算法设计保证峰值始终在搜索区间内：
- **严格递增数组**：算法持续右移，最终停在 `nums[n-1]`（因 `nums[n] = -∞`，满足峰值定义）
- **严格递减数组**：算法持续左移，停在 `nums[0]`（因 `nums[-1] = -∞`）
### 步骤：
1. **初始化指针**：
    - 设置左指针 `left = 0`，指向数组起始位置
    - 设置右指针 `right = numsSize - 1`，指向数组末尾位置
2. **二分查找循环**：
    - **当 `left < right` 时循环执行**：  
        a. 计算中点：`mid = left + (right - left) / 2`（防溢出写法）  
        b. 比较中点与右侧邻居：`nums[mid]` 与 `nums[mid + 1]`  
        c. 决策分支：
        - 若 `nums[mid] > nums[mid + 1]`：峰值在左侧，更新 `right = mid`
        - 若 `nums[mid] < nums[mid + 1]`：峰值在右侧，更新 `left = mid + 1`
3. **返回结果**：
    - 当 `left == right` 时结束循环
    - 返回 `left`（或 `right`，此时两者相等）作为峰值索引
下面是代码的具体实现：
![[Pasted image 20250709015426.png]]
### 知识点：
数组、二分查找