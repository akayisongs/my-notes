![[Pasted image 20250605155628.png]]
### 思路：
对于这道题，我开始思考最核心的问题：==如何准确获取每个数字的出现次数？==我立即意识到哈希表虽然理想但实现复杂，于是我问自己：==有没有更简洁的替代方案？==这让我联想到排序的特性：相同元素会相邻排列，这意味着我可以先对数组排序，然后通过单次遍历完成计数，这样既避免了复杂数据结构，又能利用标准库函数提高效率。
接着，我深入推敲这个方案的可行性：==排序后统计频率是否真的可靠？==为了验证，我在脑海中模拟了示例[1,2,2,1,1,3]的处理过程。排序后得到[1,1,1,2,2,3]，此时只需比较相邻元素——当数字变化时记录前一个数字的计数，整个过程如行云流水般自然。不过，我突然意识到一个关键细节：遍历结束时最后一个元素的计数容易遗漏，这促使我明确必须单独处理收尾逻辑，确保频率统计的完整性。当得到频率数组后，新的挑战浮现：==如何高效检查这些频率值是否唯一？==最初我想过用嵌套循环比较，但立刻意识到其O(n²)的复杂度太低效。这时我灵光一现：==何不再次使用排序？==将频率数组排序后，任何重复值必然相邻出现，只需一次遍历就能完成验证。例如示例[1,2]的频率[1,1]排序后相邻相等，完美符合预期。这种分阶段排序的策略，虽然增加了一次排序操作，但整体复杂度仍保持在O(n log n)，在代码简洁性与性能间取得了优雅平衡。
随后，我开始审视边界情况：==空数组或单元素数组该如何处理？==显然，它们天然满足频率唯一性条件。但更棘手的是全相同元素的数组如[5,5,5]，其频率[3]同样应该返回true。这让我确认：边界处理必须融入主流程而非事后补救。于是我决定在函数入口优先处理arrSize≤1的情况，而其他场景都通过统一逻辑处理，既避免冗余判断又保证严谨性。
最后，我聚焦到内存管理这一C语言特有的挑战。由于频率数组长度取决于不同元素的数量，我必须动态分配内存。这引发两个关键思考：首先，分配大小设为arrSize绝对安全（最坏情况所有元素不同）；其次，无论结果如何都必须释放内存，否则会造成泄漏。

### 步骤：
1. 先处理特殊情况，若数组长度≤1，直接返回true；
2. 进行数组排序预处理，使用快速排序将原数组排序，使相同数字相邻排列；。
3. 遍历统计频率，顺序扫描排序后的数组，遇到相同数字累加计数器，遇到新数字时记录前一个数字的频率并重置计数；
4. 对频率数组进行排序，将收集到的所有频率值组成新数组，再次进行快速排序；
5. 验证频率唯一性，遍历排序后的频率数组：检查相邻元素是否相等，出现任意相等则返回false；
6. 若完整遍历频率数组未发现相邻重复值，返回true，注意动态分配内存的释放操作。
下面是代码具体实现：
![[Pasted image 20250605161440.png]]

### 知识点：
数组、哈希思想