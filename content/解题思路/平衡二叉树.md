![[Pasted image 20250702204301.png]]
### 思路：
这道题是上课时讲过的平衡二叉树问题，==那么平衡二叉树的核心条件是什么？==显然，关键在于每个节点的左右子树高度差不超过1，==但如果只检查根节点的高度差就够了吗？==当然不够，因为即使根节点左右子树高度差符合要求，其子树内部仍可能不平衡。比如左子树本身就不平衡，整棵树自然也不平衡。因此，我必须递归地检查每个节点的平衡性，==那么如何高效地同时计算高度和判断平衡？==如果先计算高度再单独判断平衡，会导致重复递归遍历。比如计算根节点高度时需要遍历左右子树，判断平衡时又要重新遍历，效率低下，==有没有办法合并这两个过程？==我尝试在计算高度的过程中同步判断平衡性，若子树不平衡就立即返回特殊值提前终止，避免无效计算，然后，==在递归中遇到空节点怎么处理？==空节点没有高度，应返回0，==还有非空节点呢？==我需要先递归获取左子树高度，如果返回-1（表示不平衡）就直接向上传递；同样处理右子树高度，得到两个子树高度后，比较差值是否大于1，若大于1则返回-1标记不平衡；若符合要求则返回真实高度（左右子树最大高度+1），==关于这个递归过程是自顶向下还是自底向上的呢？==自顶向下会导致重复计算，而自底向上更高效——从叶子节点开始计算高度，逐步向根节点汇总。这样每个节点只访问一次，时间复杂度为O(n)。例如计算叶子节点时，其左右子树高度均为0，差值0，返回高度1；父节点用同样逻辑计算，直至根节点。
### 细节：
- **递归如何自底向上传递信息**？
采用**后序遍历**（左右根顺序）：
1. 先递归计算左子树高度
2. 再递归计算右子树高度
3. 最后处理当前节点：
    - 若左/右子树返回-1（不平衡），直接向上传递
    - 若左右高度差>1，返回-1标记不平衡
    - 否则返回真实高度（max(左高,右高)+1），这种顺序确保子树信息先被处理，再汇总到父节点。
### 步骤：
1. **定义二叉树节点结构**：首先需要定义树节点的数据结构。每个节点包含三个部分：一个整数值`val`存储节点数据，以及两个指针`left`和`right`分别指向左子树和右子树。当节点没有子节点时，对应的指针设为`NULL`。这是构建二叉树的基础结构；
2. **实现递归辅助函数`height()`**：创建核心的递归函数，该函数有两个功能：计算子树高度和检测平衡性。函数接收当前节点指针作为参数，返回值为整数：正常情况返回子树高度，发现不平衡时返回特殊标记-1；
3. **处理空节点情况**：在`height()`函数中，首先检查当前节点是否为空。如果是空节点（即已到达叶子节点的子节点），直接返回高度值0。这是递归的基准情况，也是递归终止的条件；
4. **递归计算左子树高度**：对当前节点的左子节点递归调用`height()`函数。如果返回值为-1（表示左子树不平衡），立即向上层返回-1。这里采用"短路"优化，避免不必要的右子树计算；
5. **递归计算右子树高度**：同样地，对当前节点的右子节点递归调用`height()`函数。如果返回值为-1（表示右子树不平衡），也立即向上层返回-1。此时左右子树都已处理完毕；
6. **检查当前节点平衡性**：计算左右子树高度的绝对差值。如果差值大于1，说明当前节点不平衡，返回-1标记不平衡状态。这是平衡二叉树的核心判断条件；
7. **计算当前子树高度**：如果当前节点平衡，计算其真实高度：取左右子树中的较大高度值，然后加1（代表当前节点自身的高度贡献）。返回这个计算结果；
8. **实现主判断函数`isBalanced()`**：最后创建公开接口函数。它调用`height()`函数并检查根节点的返回值：如果返回值不等于-1，说明整棵树平衡，返回`true`；如果返回-1，说明存在不平衡节点，返回`false`。
下面是代码的具体实现：
![[Pasted image 20250702231409.png]]
### 知识点：
dfs、二叉树