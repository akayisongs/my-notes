![[Pasted image 20250626220814.png]]
### 思路：
这道题目要求我们为一系列课程安排一个学习顺序，前提是必须先完成某些指定的先修课程。初看之下，这就像是一个安排任务前后顺序的谜题。我需要找到一个线性的排序，使得每门课都在其所有先修课的后面。如果我把每门课程看作一个点，把先修关系看作一个从“先修课”指向“后续课”的箭头，这就构成了一个有向图。那么问题就转化成了，如何在这个图中找到一条“一笔画”的路径，把所有点都穿起来，同时保证箭头的方向性。==那最直接的想法是什么？==最直接的想法就是模拟实际选课的过程。我们总是从最简单的课程开始，也就是那些没有任何先修课要求的。我可以先扫描一遍所有的课程，把那些不需要任何先修课的都找出来。这些是我第一批可以上的课。上完这些课之后，情况就发生了变化。一些原本有先修课要求的课程，它们的某个先决条件可能已经被满足了。比如课程 `A` 依赖课程 `B` 和 `C`，如果我上完了 `B`，那么 `A` 的依赖就少了一个。当 `A` 的所有依赖都清零时，`A` 就变成了下一批可以上的课。这个过程似乎可以不断重复：找到所有“已解锁”的课程 -> “上完”它们 -> 更新其他课程的“解锁”状态 -> 寻找新一批“已解锁”的课程。==如果同时有多门课没有先修要求，我该选哪一门？==假设课程 `X` 和 `Y` 一开始都没有先修要求，我先学 `X` 再学 `Y`，或者先学 `Y` 再学 `X`，会对最终能否完成所有课程有影响吗？题目说只要返回“一种”有效的顺序即可。这意味着，只要一门课的先决条件都满足了，它就是可以学习的，学习的先后顺序在同一批次中并不重要。这给了我一个启发：我可以维护一个“待学习列表”，把所有条件满足的课程都放进去，然后按顺序从这个列表中取出课程来学习。这个“先进先出”的列表，不就是**队列**数据结构吗？这个思路越来越清晰了，它很像一个广度优先搜索（BFS）的过程。我需要为每门课维护一个“待完成的先修课数量”（也就是“入度”），以及一个“学完这门课能解锁哪些后续课程”的列表（也就是“邻接表”）。==但万一这个过程卡住了怎么办？==“卡住了”意味着我的“待学习队列”已经空了，但是还有课程没有被安排到学习顺序中。这种情况为什么会发生？这必然是因为剩下那些未安排的课程，它们的“待完成的预修课数量”永远无法清零。例如，课程 `A` 依赖 `B`，课程 `B` 又依赖 `A`。这样 `A` 和 `B` 都在互相等待，谁也无法成为那个“入度为0”的起点。所以这就是一个**环形依赖**。如果在整个流程结束后，我排出的课程总数小于题目给定的课程总数，那就说明图中存在环，学习计划无法完成。最终，我可以通过模拟选课来解决这个问题。首先，通过遍历先修关系，建立起每门课的入度计数和后续课程邻接表。然后，将所有初始入度为0的课程放入一个队列。接着，不断地从队列中取出课程，将其加入最终的学习顺序中，并更新其所有后续课程的入度。如果一个后续课程的入度因此变为0，就将其也加入队列。最后，比较排出的课程总数和总课程数是否相等，即可判断是否存在一个有效的学习顺序。这个带有探索性的思考过程，最终将我引向了拓扑排序中的Kahn算法。
### 细节：
- **Kahn算法为何优于DFS实现**？
    直观性：通过入度统计直接定位起点课程
    效率性：O(V+E)时间复杂度与DFS相当
    检测优势：队列提前空置即可判定环存在
    空间优化：无需递归栈避免栈溢出风险
    这些特性使其成为工业级解决方案的首选

### 步骤：
1. 创建入度数组 indegree：记录每门课程的先修课程数量，初始化邻接表 graph：存储每门课程的后继课程列表，创建邻接表大小数组 graphSize：记录每门课程的后继课程数量，分配辅助计数数组 count：用于填充邻接表；
2. 第一次遍历先决条件数组：对每个依赖关系 [a, b]（表示学习a前需先学b），增加 graphSize[b]（b的出度），增加 indegree[a]（a的入度）；
3. 为邻接表分配空间：根据 graphSize 为每门课程分配后继列表空间；
4. 第二次遍历先决条件数组：将课程 a 加入课程 b 的后继列表，使用 count 数组跟踪填充位置；
5. 创建队列数组 queue，遍历所有课程，将入度为0的课程加入队列，设置队列头尾指针 front=0, rear=入度0课程数；
6. 执行拓扑排序；
7. 结果返回和内存释放。
下面是代码的具体实现：
![[Pasted image 20250627001058.png]]
![[Pasted image 20250627001157.png]]
### 知识点：
图