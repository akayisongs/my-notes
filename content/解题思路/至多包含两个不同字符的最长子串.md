![[Pasted image 20250608212352.png]]
### 思路：
这道题要求在一个字符串中寻找最长子串，且该子串最多只能包含两个不同的字符。这类似于经典的滑动窗口问题，但需要特别关注字符种类的动态变化。关键是要在遍历过程中实时监控窗口内字符种类数量，确保其不超过2，同时记录满足条件的最大窗口长度。那么采用什么算法能高效解决这个问题呢？滑动窗口算法是最佳选择。其核心在于使用双指针动态维护一个合法窗口：右指针负责扩展窗口，不断纳入新字符；左指针负责收缩窗口，当字符种类超过限制时进行压缩。这样能确保每个字符最多被访问两次，时间复杂度控制在O(n)，远优于暴力解法的O(n^2)，那么具体如何实现字符种类的监控呢？通过长度为128的ASCII计数数组实现高效监控。当右指针纳入新字符时：若该字符计数从0变为1，则种类数加1；当左指针移出字符时：若该字符计数从1降为0，则种类数减1。这种设计使得字符种类的增减操作都能在O(1)时间内完成。那么窗口收缩的条件是什么呢？当窗口内字符种类超过2时触发收缩。具体操作是：移动左指针，将指向的字符从计数数组中移出（计数减1），若其计数归零则减少种类统计。循环此过程直到种类数回落到2以内，确保窗口重新满足条件。那么如何记录最大长度？每次窗口调整后，立即计算当前窗口长度right-left+1，并与历史最大值比较更新。这个时机很关键，必须在完成可能存在的收缩操作后更新，才能保证记录的都是合法窗口的长度。那有什么特殊情况吗？当字符串长度≤2时可直接返回长度，避免不必要的计算。初始化时所有字符计数置零，确保从空白状态开始构建窗口。移动右指针时的字符纳入操作总是优先执行，保证所有字符都能被正确处理。
### 步骤：
1. 初始化长度为128的ASCII字符计数数组、不同字符计数器distinct、左指针left和最大长度记录max_len；
2. 使用右指针right遍历字符串，每纳入一个新字符就更新其计数，若该字符首次出现则distinct加1。当distinct超过2时启动窗口收缩：移动左指针left，将移出字符的计数减1，若计数归零则distinct减1，直至不同字符数回落至2以内。每次调整窗口后立即计算当前窗口长度right-left+1，并更新历史最大值max_len；
3. 遍历完成时返回记录的max_len值。整个过程确保每个字符最多被访问两次；
下面是代码的具体实现：
![[Pasted image 20250609003949.png]]

### 知识点：
哈希表、滑动窗口
