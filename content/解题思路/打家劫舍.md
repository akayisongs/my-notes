![[Pasted image 20250626185808.png]]
### 思路：
这道题让我作为一个小偷，需要从一排房屋中偷取现金，但任何相邻的房屋都不能同时偷窃，否则会触发报警，目标是在这个条件下最大化总金额。
那么，==**该如何系统地解决这个问题呢**？==例如，如果没有房屋，显然我只能得到0；如果只有一间房屋，那么唯一的方案就是偷它，金额就是该房屋的值；如果有两间房屋，由于它们相邻，我只能选择金额较大的那一间偷窃。这些简单情况是基础，但现实问题通常涉及更多房屋，因此我需要一个更通用的方法。==**如何将复杂问题分解为更小的子问题**？==考虑三间房屋的情况，金额分别为a、b、c。我的选择有偷第一间和第三间（a+c），或者只偷第二间（b），或者偷第一间或第三间但放弃其他。但为了最大化，我必须比较a+c和b的大小，因为偷a+c可能更优，也可能不优，对于第i间房屋，最大金额取决于前i-1间房屋的解：如果我不偷第i间，金额等于偷到第i-1间的最大值；如果我偷第i间，就不能偷第i-1间，因此金额等于偷到第i-2间的最大值加上当前房屋金额。因此，动态规划的思路自然浮现：定义状态dp[i]为偷到第i间房屋时的最大金额，转移方程为dp[i] = max(dp[i-1], dp[i-2] + nums[i])。==**为什么动态规划适合这里**？==因为问题具有最优子结构，全局最优解依赖于子问题的最优解，且子问题重叠。==**如何高效实现呢**？==既然每个状态只依赖前两个状态，我无需存储整个dp数组，只需用两个变量prev_prev和prev分别记录dp[i-2]和dp[i-1]，在遍历数组时更新它们即可，这样，空间复杂度优化到O(1)，而时间复杂度保持O(n)，非常高效，**边界条件和初始状态如何设置**？初始时，对于第一间房屋，dp[0] = nums[0]；对于第二间，dp[1] = max(nums[0], nums[1])。然后从第三间开始循环，应用状态转移方程。同时，我必须处理特殊输入，比如空数组返回0，单元素数组直接返回该元素。
### 细节：
- **为什么动态规划比暴力搜索更高效**？
    暴力搜索需要遍历所有2^n种组合，而动态规划可以消除冗余计算，每个子问题只解一次，还可以避免无效路径，通过max()函数剪枝非最优分支，时间复杂度O(n)：单次遍历即可完成，这种效率提升源于对问题重叠子问题特性的充分利用。
### 步骤：
1. 首先检查房屋数量（数组长度）的特殊情况，若数组为空（numsSize == 0），直接返回0，若只有一间房屋（numsSize == 1），返回该房屋金额；
2. 创建两个关键变量记录历史最优解：prev_prev = nums[0]：表示偷窃到第0间房屋时的最大金额prev = max(nums[0], nums[1])：表示偷窃到第1间房屋时的最大金额；
3. 从第三间房屋开始（下标i = 2）遍历整个数组，计算当前最优解：current = max(prev, prev_prev + nums[i])，比较"不偷当前屋（继承前值）" vs "偷当前屋（跳过前屋）"滚动更新状态，将prev_prev更新为上一轮的prev，并将prev更新为本轮计算的current；
4. 遍历结束后，prev存储的就是考虑所有房屋时的全局最优解，直接将其作为结果返回。
下面是代码的具体实现：
![[Pasted image 20250626213225.png]]
### 知识点：
数组、动态规划