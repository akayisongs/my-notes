
*想到写普里姆算法的原因主要是最近老师上课时讲了普里姆算法算法的大致思路，对代码细节并未仔细完善，再加上在过程中我曾突发奇想的一种思路又恰是克鲁斯卡尔算法一点雏形，遂想记录下当时所想并进行代码实现*
### 要求：连通网的最小生成树
### 思路：
该题目关键在于在该连通网所有生成树中找到**最小代价**的生成树，因为该生成树一定包含连通网中所有顶点，故不妨以第一个顶点作为该生成树的根节点(也可给定)，然后再找到与其相邻的点权值最小的边，再在未选顶点中找到与已选顶点相连权值最小的一条边另一头的顶点，如此反复一直到所有边都被选；那么该思路究竟能不能形成最小生成树呢？首先**所有顶点**都被包含在内了，其次**每个连通子图的最小权值邻接边**都被包含在内了，类似于贪心算法的思想？说明确实能够生成最小生成树，那么选边可不可以呢？*可以确定的是权值最小的边一定能出现*，但是所有相对最小的边都会出现吗？好像没那么简单...再回到普里姆算法中，如何实现其中的一些细节呢？

### 关键步骤：
- 对于各顶点是否已被选中，可以用一个记号数组***collected***来实现，注意被选中的记为***1***，为被选中的记为***0***；
- 对于已被选中的各顶点与它们邻接点之间的边的权值的读取和比较则另需一个***Dist***数组，因为比较时需要满足与已选顶点邻接且未被选中，该数组从连通网的邻接矩阵中读取，注意初始化时将所有设为***INF***极大值；
- 由于在输出时还需要把最小权值节点的父节点也打印出来，所以还需一个***parent***数组来记录该顶点的父节点的下标，注意初始化时将所有都设为-1；
- 注意每个节点在各个数组的下标都是按照邻接矩阵确定下来的。
具体函数实现如下图：
![[Pasted image 20250529232609.png]]
### 知识点：
普里姆算法，带权图，最小生成树
### 细节：
注意学习新算法时一定要多思考，用发散的思维甚至可以优化算法

