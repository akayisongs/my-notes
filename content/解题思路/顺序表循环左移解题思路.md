![[Pasted image 20250529004145.png]]
![[Pasted image 20250529004221.png]]
### 思路和步骤：
这道题是考数据结构期中考时之前遇到过还没做出来的题😡，关键在于如何在时间和空间效率都较高的算法，观察可以知道，裁判程序中该函数会有返回值***ERROR***，原因为移动位数不对，故该函数在执行核心代码之前应核对***p***的值是否合法，同理知最后完成移动后该函数应返回***ok***；

==***对于核心代码段***==，我最开始的想法是利用两个循环先将原数组中第***p+1***项到第***n***项逐个存入新数组中，再将剩余第***1***项到第***p***项存入数组，新数组以题目中的常量***N***为数组大小，最后用一个循环将原数组用新数组的值覆盖掉，实现代码如下：
![[Pasted image 20250529134755.png]]
    *虽然该段代码的==时间复杂度==为：**O(n)**，==空间复杂度==为：**O(1)**，但由于辅助空间**M**数组占用固定的***N***个空间，如果**n**远小于**N**则会浪费大量空间，同时其循环次数也较多，会不会有更优的算法呢？*
我首先想到能不能在原数组中直接交换元素位置呢？因为交换后的数组中**元素本身没有改变**，只是他们的顺序发生了变化，所以理论上是可行的；其次，如果是进行**元素位置交换**，需要用到的辅助空间只需要一个元素的大小，可以提高空间效率，那么如何实现呢？

观察可以发现，**新序列如果从*X0*项看成两个单独的数组，两个数组分别倒置形成的新序列刚好为原序列的全倒叙**，有了这个思路之后，编程过程其实就是上述思路的**逆过程**，实现代码如下：
![[Pasted image 20250529140146.png]]
    *该段代码时间复杂度为：**O(n)**，空间复杂度为：**O(1)**，且循环次数较少，辅助空间较少，整体效率较高*
### 知识点：
数组、倒序、时间和空间效率


