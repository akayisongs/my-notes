![[Pasted image 20250617214423.png]]
### 思路：
这道题题目说的**翻转二叉树到底意味着什么**？其实就是把每个节点的左右子树互换位置，就像照镜子一样让整棵树左右对称。比如输入 [4,2,7,1,3,6,9]，翻转后应该变成 [4,7,2,9,6,3,1]，这让我想到二叉树通常用递归处理，**那么递归的终止条件应该是什么呢**？显然，当遇到空节点时就应该停止递归，因为空节点没有子树可翻转，**那么对于非空节点，又该如何处理**？我意识到需要先递归处理它的左右子树，确保子树已经翻转好，然后再交换当前节点的左右子树。因为如果先交换再递归，子树结构就被打乱了，**那么为什么需要先递归子树再交换**？因为翻转操作是自底向上的，就像搭积木时先组装好零件再整体拼接。具体来说，对于节点2，我需要先翻转它的左右子树，然后再交换它们的位置。如果顺序颠倒，可能会得到错误结果，**如果节点只有一个子树怎么办**？比如节点只有左子树没有右子树，经过推演，我发现这种场景下翻转后，原来的左子树会变成右子树，而左子树变为空，这完全符合逻辑。同样地，叶子节点没有子树，直接返回自身即可。由于每个节点只访问一次，时间复杂度是O(n)；而递归栈深度取决于树高，所以空间复杂度在平衡树是O(log n)，最坏情况是O(n)。
### 细节：
- **先处理根节点还是先处理子树**？
    采用**后序遍历（深度优先）**
    1. 先递归处理左子树
    2. 再递归处理右子树
    3. 最后交换当前节点的左右子树
    这样的操作自底向上操作，确保子树已翻转完成再处理当前节点，避免子树结构混乱。
### 步骤：
1. **递归终止条件检查**
- 判断当前节点是否为空
- 若为空节点（`root == NULL`），直接返回 `NULL`
- 处理叶子节点的子树和空树边界情况
 2. **递归翻转左子树**
- 对左子树调用翻转函数：  
    `left = invertTree(root->left)`
3. **递归翻转右子树**
- 对右子树调用翻转函数：  
    `right = invertTree(root->right)`
- **关键点**：  
    深度优先遍历到最右侧叶子节点
- **效果**：  
    获取已翻转的右子树结构
4. **交换左右子树**
- 执行指针交换操作：
    root->left = right;  // 原右子树变为左子树
    root->right = left;  // 原左子树变为右子树
5. **返回当前节点**
- 返回处理完成的节点：  
    `return root`
下面是代码的具体实现：
![[Pasted image 20250618002305.png]]
### 知识点：
二叉树