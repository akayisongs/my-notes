![[Pasted image 20250614211638.png]]
### 思路：
这道题是要解决寻找数组多数元素的问题，那**多数元素的定义是什么呢**？即在长度为n的数组中重复出现次数严格超过⌊n/2⌋的元素，题目已明确保证数组非空且必然存在这样的元素，那么**我们应该如何高效找到多数元素呢**？我们可以通过元素间的动态抵消机制，将多数元素视为一个阵营，其他元素视为对立阵营，那么**如何反映当前阵营的力量对比呢**？通过计数器即可实现实时反映，**具体如何实现呢**？我们可以初始化候选元素为数组首元素，计数器设为1；随后遍历数组，当遇到相同元素时增加计数，遇到不同元素时减少计数，若计数器归零则立即更换候选元素。**这个算法是如何最后得到答案的呢**？这种抵消机制的有效性建立在多数元素的绝对数量优势上，设其出现次数为k，则必有k > ⌊n/2⌋即k ≥ ⌊n/2⌋+1，即使所有非多数元素都参与抵消，最终仍会剩余至少2k-n ≥ 1个多数元素。因此当遍历结束时，最后留在计数器中的候选元素必然是多数元素。此算法仅需O(n)时间复杂度和O(1)空间复杂度，且由于题目保证解的存在，无需额外验证结果。
### 细节：
- **代码实现有哪些需要注意？**
    实现时需注意三个边界逻辑。第一，初始化候选为数组首元素，计数器为1，这是遍历的起点。第二，遇到不同元素时计数器减1，这代表抵消操作。第三，当计数器归零时，下一元素立即成为新候选（相当于重置阵营）。例如数组[3,2,3]中，当首元素3遇到2时计数器归零，随后第三个元素3成为新候选。这些步骤确保了算法对任意顺序的数组都有效。
- **为什么选择这种划分阵营的算法解决这个问题？**
    因为该算法具有显著的时间和空间优势。首先，它只需遍历数组一次，时间复杂度为O(n)；其次，它仅需两个额外变量（候选元素和计数器），空间复杂度为O(1)。相比之下，若使用哈希表统计频率，虽然时间也是O(n)，但需要O(n)额外空间；若采用排序后取中位数的方法，时间复杂度会升至O(n log n)。
### 步骤：
1. 将数组的第一个元素设为候选多数元素 candidate，设置计数器 count = 1，表示当前候选元素的支持度；
2. 从数组的第二个元素开始对每个元素执行以下操作：
    a. 检查计数器是否归零，若 count == 0，则将当前元素设为新的候选元素 candidate = nums[i]并重置计数器 count = 1；
    b. 处理相同元素，若当前元素等于候选元素 nums[i] == candidate，则增加计数器 count++
    c. 处理不同元素，若当前元素不等于候选元素 nums[i] != candidate，则减少计数器 count--；
3. 完成整个数组遍历后，直接返回最终保留的候选元素 candidate
下面是代码的具体实现：
![[Pasted image 20250614213541.png]]
### 知识点：
数组