![[Pasted image 20250606214335.png]]
### 思路：
这道题的关键是模拟腐烂橘子的扩散过程。腐烂橘子的扩散本质上是一个多源点同时传播的过程，这让我联想到图论中的最短路径问题。我们可以将整个网格看作一个图，每个单元格是一个节点，相邻的单元格之间有边。腐烂的过程，就是从所有初始腐烂的橘子节点出发，寻找到达所有新鲜橘子节点的最短路径。==所以这道题的本质是什么？==其本质就是一个**BFS**问题。初始状态下所有的腐烂橘子就是BFS的多个源头。BFS算法的特性是逐层向外探索，这与腐烂过程每分钟向外扩散一圈的特性完美契合。因此，BFS搜索的层数，就恰好对应着所有新鲜橘子完全腐烂所需的最短时间（分钟数）。使用BFS，我们可以确保找到的是最短时间，因为它总是先处理完距离源点近的节点，再处理远的节点。明确了使用BFS后，接下来的问题就是具体实现。==如何高效地模拟这个扩散过程？==首先，我们需要一个队列数据结构，这是实现BFS的核心。在模拟开始前，我们需要进行一次预处理：遍历整个网格，将所有初始状态为腐烂的橘子（值为2）的坐标全部加入队列中，作为BFS的第一层。同时，我们还需要统计出网格中所有新鲜橘子（值为1）的总数，记为fresh。这个计数器至关重要，它将作为我们判断最终是否所有橘子都成功腐烂的依据。接下来，我们启动BFS主循环，这个循环的每一次迭代都代表着时间的流逝。==如何精确地计算时间（分钟数）？==为了精确计时，我们采用分层遍历的技巧。在每一轮外层循环开始时，我们先记录下当前队列中的橘子数量，这个数量代表了在当前这一分钟需要处理的所有腐烂源。然后，用一个内层循环，将这些橘子逐一出队。每取出一个腐烂橘子，就检查其上下左右四个方向的邻居。如果邻居是新鲜橘子，就将其“感染”——状态置为2，并将其坐标加入队列尾部，同时将fresh减一。当内层循环结束，意味着这一分钟的扩散过程已经完成。此时，如果队列中还有橘子（即下一分钟还有扩散任务），我们就将分钟计数器加一。这个过程不断重复，直到队列为空。最后，当BFS循环终止，即队列为空时，腐烂过程彻底停止。==如何判断最终是否所有橘子都腐烂了？==此时，我们检查在预处理阶段统计的fresh计数器。如果在整个BFS过程中，每次感染都正确地将fresh减一，那么在循环结束后：
   - 如果fresh的值为0，说明所有最初的新鲜橘子都已被成功感染。那么，我们累计的分钟数就是最终答案。
   - 如果fresh的值大于0，则说明有部分新鲜橘子因为被空单元格包围等原因，始终无法被任何腐烂源触及。在这种情况下，任务不可能完成，我们应按题目要求返回-1。此外，还需要注意一个边界情况：如果初始网格中根本没有新鲜橘子，那么所需时间为0。
### 细节：
- 在BFS过程中，如何精确地计算时间（分钟数）？
    时间是通过**分层遍历**来精确计算的。BFS的主体是一个`while`循环，只要队列不为空就持续进行。在每一轮循环（代表一分钟）开始时，需要先记录下**当前队列的大小**（`level_size`）。然后，用一个内层循环，不多不少地只处理这`level_size`个橘子。当内层循环结束后，意味着这一分钟的扩散已经全部完成。此时，如果队列中还有待处理的橘子（即下一分钟还有扩散任务），就将分钟计数器加一。通过这种方式，分钟数与BFS的层数完美对应。
- 需要注意哪些特殊的边界情况？
    **如果初始网格中根本没有新鲜橘子**，在这种情况下，不需要任何时间，腐烂过程已经“完成”。因此，应在预处理阶段就进行判断，如果新鲜橘子数量为0，直接返回**0**。

### 步骤：
1. 初始化状态扫描，遍历整个网格， 统计所有新鲜橘子的数量，记录在fresh变量中，并将所有腐烂橘子的坐标加入队列，作为BFS的起点，若初始状态fresh=0，直接返回0分钟；
2. BFS层级初始化，设置分钟计数器minutes = -1，定义四个扩散方向，上( -1, 0 )、下( 1, 0 )、左( 0, -1 )、右( 0, 1 )
3. 层级遍历：下图为具体实现流程图![[Pasted image 20250606224107.png]]
4. 循环结束后，若fresh > 0，存在无法腐烂的橘子则返回-1，若fresh = 0，所有橘子已腐烂则返回分钟数。
下面是代码具体实现：
![[Pasted image 20250607002120.png]]

### 知识点：
图，广度优先搜索