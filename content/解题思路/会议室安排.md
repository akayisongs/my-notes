![[Pasted image 20250613150542.png]]
### 思路：
首先，==我思考这个问题的本质是什么？==题目要求计算安排一系列会议所需的最小会议室数量，每个会议都有固定的开始和结束时间。这让我联想到时间轴上的线段重叠问题——当多个会议在时间上重叠时，它们不能共用同一个会议室。那么关键就在于找到最大重叠的会议数量，因为那就是所需的最小会议室数。但问题在于时间轴是连续的，范围可能非常大，直接遍历每个时间点显然不可行。
既然如此，我进一步思考：真正影响会议室使用变化的其实只有会议的开始和结束时刻这些离散的时间点。==那么，我能否只关注这些关键事件点呢？==这个思路让我豁然开朗：如果我把所有会议的开始时间和结束时间分别提取出来，各自排序，就能按时间顺序模拟会议室的使用情况了==。不过，具体要如何模拟呢？==这时我想到用双指针技巧：一个指针扫描开始时间数组，另一个扫描结束时间数组。当开始时间指针指向的时间小于结束时间指针指向的时间时，说明有新会议要开始但还没有会议结束，此时需要增加会议室计数；反之则说明有会议结束，可以释放会议室。
但在实现这个逻辑时，我遇到了一个细节问题：==如果开始时间等于结束时间该怎么处理？==想象一个会议在10:00结束而另一个在10:00开始的情况。经过反复推敲，我意识到应该优先处理结束事件——因为会议结束的瞬间会议室就空出来了，新会议可以立即复用这个房间。如果不这样处理，就会多算一个会议室，导致结果偏大。这种"结束优先"的处理方式完美解决了时间点重合的边界情况。
接着我思考这种方法的正确性：==为什么双指针遍历能准确反映最大会议室需求？==关键在于排序后的事件序列保持了时间顺序，而双指针的移动确保了每次处理的都是最早发生的事件。当新会议开始时计数器增加，会议结束时计数器减少，整个过程就像坐过山车一样——计数器上升时记录峰值，这个峰值就是我们需要的最小会议室数。有趣的是，这种方法甚至能自动处理多个会议同时开始或结束的情况，因为排序后相同时间的事件会连续出现，计数器会相应增减。
最后我评估了方案的效率：提取两个数组需要O(n)空间，排序需要O(n log n)时间，双指针遍历是O(n)时间。虽然排序是主要开销，但对于10^6规模的会议数据，现代计算机完全能快速处理。
### 细节：
- **该题的max变量更新最大房间数的计数逻辑是什么**？
    为什么要在处理开始事件时更新最大房间数？因为只有新会议开始时，当前会议数量才会增加；而处理结束事件只会减少会议数量。因此每次新增会议时，我们都检查并更新历史最高峰值的会议数量。这就像潮汐记录，涨潮时更新最高水位线，退潮时不影响记录。
- **该题是如何保证其正确性的呢**？
    因为通过双指针按时间线推进，我们模拟了每个会议事件的真实发生顺序。排序确保时间有序，指针移动保证及时处理结束事件，计数机制精确捕捉重叠峰值。整个过程就像机场调度：起飞（结束）和降落（开始）事件按时刻表处理，塔台始终保持对跑道占用峰值的监控。
### 步骤：
1. 创建两个独立数组：`starts` 数组存储所有会议的开始时间，`ends` 数组存储所有会议的结束时间，通过遍历输入数组 `intervals` 完成数据填充；
2. 对两个数组分别进行升序排序：使用快速排序对 `starts` 数组 ，`ends` 数组排序，确保所有会议事件按时间顺序排列；
3. 设置四个关键变量：
   `start_ptr`：指向当前待处理的开始时间      
   `end_ptr`：指向当前待处理的结束时间
   `count`：记录当前进行中的会议数量
   `max_count`：记录历史最大会议数量；
4. 当开始指针未处理完时循环：
- **情况1**：当存在结束事件且当前开始时间 ≥ 结束指针时间  
    减少`count`（表示会议结束释放房间）  
    结束指针`end_ptr`后移
    
- **情况2**：当前开始时间 < 结束指针时间  
    增加`count`（表示新会议需要房间）  
    开始指针`start_ptr`后移  
    更新`max_count = max(max_count, count)`；
5. 当所有开始事件处理完毕后，最终返回`max_count`作为结果；
6. 返回结果前释放动态分配的两数组内存。
下面是代码的具体实现：
![[Pasted image 20250613195637.png]]
### 知识点：
数组、贪心、双指针