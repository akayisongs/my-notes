![[Pasted image 20250625183911.png]]
### 思路：
这道题如果当做数学题来解决的话，会相当简单，首先，我回忆起基础的几何知识：三点共线的条件是任意两点间的斜率相等。这个认知让我想到，或许可以通过计算斜率来解决。但紧接着就产生了疑问：==如何高效地处理大量点呢？==毕竟，最粗暴的三重循环检查所有三点组合，时间复杂度高达O(n³)，对于300个点来说显然不可行。这时我意识到，需要更聪明的策略。
那么，==能否找到一个点作为"锚点"，然后考察它与其他点的关系呢？==这个想法让我豁然开朗。具体而言，我可以遍历每个点作为基准点，计算它与其余所有点连线的斜率，统计相同斜率的出现频率。这样，相同斜率的点数加上基准点本身，就是通过该基准点的直线上包含的点数。最后取所有基准点结果的最大值即可。这个思路将复杂度降到了O(n²)，是质的飞跃。不过，新的问题接踵而至：==如何精确表示斜率？==直接使用浮点数显然行不通，因为计算机浮点运算存在精度问题，可能导致两个数学上相等的斜率在比较时出现偏差。比如，当坐标值较大时，(1,2)和(2,4)本应相同，但浮点除法结果可能略有差异。这促使我寻找更可靠的表示方法——用分数的最简形式表示斜率。具体而言，用分子(dx)和分母(dy)组成的整数对，通过最大公约数约分，并统一符号（使分母为正），就能精确唯一地表示每个斜率。
想到这里，我又意识到需要处理特殊直线。==垂直线怎么办？==因为此时dx为零，斜率无定义。经过思考，我决定用(1,0)表示所有垂直线。类似地，水平线则用(0,1)表示。这样，所有直线都有了统一的数学表示，包括特殊情况也得到了优雅处理。接下来，效率问题浮现脑海。==如何快速统计相同斜率的数量？==排序后统计连续重复元素是自然的选择。因为排序后相同斜率会相邻排列，只需线性扫描就能得到最大连续计数。虽然排序增加了一些复杂度，但整体仍保持在O(n² log n)的合理范围内，对于300个点完全可行。
在具体实现前，我还反复推敲了几个边界情况。==如果只有一个点怎么办？==显然结果应该是1。==如果所有点都相同呢？==但题目已说明所有点互不相同，所以无需考虑。还有，当dx和dy异号时如何处理？我决定在约分后统一调整符号，确保分母为正，这样(-1,2)和(1,-2)都会规范化为(-1,2)表示。
### 细节：
- **如何避免浮点数精度问题？**
直接使用浮点数存储斜率（如dy/dx）会导致精度误差。例如，(1,2)和(2,4)本应斜率相同，但浮点计算可能因舍入误差被误判为不同。解决方案是用分数形式表示斜率：
- 将斜率表示为最简分数对`(dx, dy)`
- 计算`dx = x_j - x_i`，`dy = y_j - y_i`
- 用最大公约数（GCD）约分：`g = gcd(|dx|, |dy|)`，`dx /= g`，`dy /= g`
- **符号规范化**：若`dy < 0`，则取反`dx`和`dy`，保证分母为正
特殊直线单独处理：
- **垂直线**（dx=0）：表示为`(1, 0)`
- **水平线**（dy=0）：表示为`(0, 1)`
### 步骤：
1. 处理特殊情况 当点数为1时，直接返回1（单个点始终在一条"直线"上）
当点数为2时，直接返回2（两个点必然共线）
2. 初始化最大点数 设置全局最大值max_count = 2（至少两个点共线）
3. 遍历每个基准点 对每个点i执行以下操作：
创建斜率数组slopes（大小为n-1）
初始化斜率计数count = 0
4. 计算相对斜率 对于每个非基准点j（j ≠ i）：
计算坐标差：
dx = x_j - x_i
dy = y_j - y_i
处理特殊直线：
垂直线（dx = 0）：斜率表示为(1, 0)
水平线（dy = 0）：斜率表示为(0, 1)
处理一般直线：
计算绝对值最大公约数：g = gcd(|dx|, |dy|)
约分化简：dx /= g，dy /= g
符号规范化：
若dy < 0：dx = -dx，dy = -dy（保证分母为正）
若dy > 0：保持不变（分子符号自由）
存储斜率对(dx, dy)
5. 统计相同斜率 排序斜率数组：
先按dx升序排列
dx相同时按dy升序排列
扫描连续相同斜率：
初始化same = 1（当前斜率连续计数）
初始化max_same = 1（当前基准点的最大连续计数）
遍历排序后的斜率数组：
若当前斜率等于前一个斜率：same++
否则：更新max_same = max(max_same, same)，重置same = 1
最后再更新一次max_same（处理末尾连续段）
6. 更新全局最大值 当前直线点数 = max_same + 1（含基准点）
更新全局最大值：max_count = max(max_count, max_same + 1)
7. 返回结果 遍历完成后返回max_count
下面是代码的具体实现：
![[Pasted image 20250710000444.png]]![[Pasted image 20250710000512.png]]
### 知识点：
几何、数组、哈希表