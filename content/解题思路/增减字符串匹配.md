![[Pasted image 20250623012805.png]]
### 思路：
这道题既然排列必须包含 [0, n] 的所有整数，**那么能否用两个指针动态管理可用数字范围**？于是设定 low=0 和 high=n 作为当前可用数字的边界。那么当遇到 'I' 时，**为什么选择最小值最合理**？因为若当前位置放置较小数字，后续无论需要更大还是更小的数字都有调整空间，下一个数字只要大于当前值就能满足 'I'，而即使后续是 'D'，也可通过放置比当前值更小的数字实现。反之，若当前位置放置较大数字，后续可能无法找到足够小的数字满足 'D'，接下来考虑 'D' 的情况，**为什么此时要选择最大值**？类似地，放置较大数字后，后续可用数字都小于该值，自然满足当前 'D' 要求；而若后续需要 'I'，仍有较小数字可供选择。这种策略的精妙之处在于，每次操作后可用数字范围收缩，但始终保持连续区间。**那么当遍历完字符串后如何处理**？此时已放置n个数字，剩下唯一未用的数字正好是 low 和 high 重合的值（因为每次移动指针都消耗一个数字），将其放在排列末尾即可。以 "IDID" 为例：先放最小值0(I)，再放最大值4(D)，接着放最小值1(I)，然后放最大值3(D)，最后剩余2放末尾，形成 [0,4,1,3,2] 满足 0<4>1<3>2。
### 细节：
- **这种方法为何能保证不重复使用数字**？
    因为每次放置后指针立即移动，确保每个数字只用一次。边界情况如全 'I' 字符串：顺序放置最小值得 [0,1,2,3]；全 'D' 字符串：逆序放置最大值得 [3,2,1,0]，均完美符合要求。整个过程就像在走钢丝：'I' 时踩最低点保持平衡，'D' 时踏最高点维持稳定，最后一步自然落地。
### 步骤：
1. 生成一个由 [0, n] 范围内所有整数组成的排列（n 为字符串长度），使得每个字符位置满足 'I' 表示后项大于前项、'D' 表示后项小于前项；
2. 确定字符串长度 `n` 后，立即设置排列长度为 `n+1`，并分配内存空间存储结果；
3. low=0 表示当前可用数字的最小值，high=n 表示最大值，这两个指针将动态界定可用数字的连续区间；
4. 当遇到 'I' 时，将当前最小值 low 放入排列的当前位置，随后将 low 指针右移增大；
5. 这一操作确保当前位置的值小于所有剩余数字，为后续 'I' 或 'D' 留出空间。相反，当遇到 'D' 时，将当前最大值 high 放入排列，并将 high 指针左移减小；
6. 此时 low 和 high 必然重合，将剩余的唯一数字（如 "IDID" 中的 2）放入排列末尾，最终返回构造好的排列及其长度。
下面是代码的具体实现：
![[Pasted image 20250623015238.png]]
### 知识点：
贪心、数组、双指针