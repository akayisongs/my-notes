![[Pasted image 20250716224621.png]]
### 思路：
给定一棵二叉树和目标值，必须找出所有从根节点到叶子节点的完整路径，且路径上节点值之和恰好等于目标值。这让我联想到树木的生长——每条从根到叶的路径都是独特的生命线，而我们的任务就是找出那些"能量总和"精确匹配目标的生命线。
**那么，==什么样的算法能系统性地探索所有路径呢？==** 深度优先搜索（DFS）立刻浮现在脑海中。就像探险者执着于一条路径直至尽头，DFS天然适合这种需要完整走通路径的场景。但随即产生新的疑问：==**如何记录这些瞬息万变的路径？==** 想象手握一根可以伸缩的测量绳——每向下探索一个节点，就在绳子上做个标记；当退回到分岔路口时，就擦除最后的标记。在代码中，这个"测量绳"就是动态数组：用数组索引模拟绳子长度，深入时追加节点值，回溯时索引回退，这种设计既避免频繁内存分配，又能精确记录路径状态。
**==紧接着面临关键挑战：如何判断路径是否有效？==** 这里采用"递减验证法"让我豁然开朗。初始时手持全部目标值"资金"，每经过一个节点就支付相应"成本"。当抵达叶子节点时，若资金恰好归零，则说明路径完美匹配。这个方法比维护累加和更巧妙，因为递归函数只需传递单值参数，大幅简化状态管理。特别注意到题目允许负数值，这种减法策略依然能正确处理负债情况。
==**当发现有效路径时，如何永久保存？==** 这是最易出错的环节。最初我考虑直接记录路径数组指针，但立刻意识到陷阱：回溯时路径内容会被覆盖！如同沙地上的画作会被潮水抹去。解决方案是立即制作"路径快照"——用memcpy复制当前路径到独立内存区块。这引发出新的思考：==**如何管理海量路径的内存？** ==设计动态扩容的结果集：初始分配10条路径空间，当空间不足时倍增容量。这种策略在空间效率和时间效率间取得平衡，避免每次添加路径都触发昂贵的内存分配。
**==最后构建递归框架时，如何确保没有纰漏？==** 核心在于把握三个关键时刻：进入节点时，将节点值压入路径栈并更新剩余值；到达叶子时，检查剩余值决定是否保存路径；离开节点前，通过栈指针回退实现回溯。特别注意处理空节点边界条件，就像在悬崖边及时止步。对于只有单个节点的树，需要验证它既是叶子又值等目标值；对于目标值为零的特殊情况，算法也能正确处理。
### 细节：
- **如何处理空树和边界情况**？
    空树：直接返回空结果（* returnSize=0），单节点树：直接判断该节点值是否等于目标和负数值：路径和可能递减或递增，但算法天然支持大整数，溢出：题目限定32位整数，无需特殊处理，重复路径：二叉树结构保证路径不会重复。
### 步骤：
1. 创建结果集结构体 PathSumResult，包含：
    result：二维指针数组存储路径
    columnSizes：一维数组存储每条路径长度
    path：当前路径动态数组
    pathTop：当前路径栈顶指针
    size：已找到路径数
    capacity：结果集当前容量
    初始化路径数组：分配初始内存（如4个元素）
2. 深度优先搜索（DFS）遍历
    路径记录：将当前节点值加入路径数组
    容量管理：路径数组满时倍增容量
    目标更新：从目标和减去当前节点值
3. 叶子节点验证：左右子节点均为空
   路径和验证：剩余目标和为0
   路径保存：深拷贝当前路径到结果集
   结果集扩容：按需倍增存储空间
4. 递归遍历子树，左子树优先：先递归遍历左子树
   右子树次之：再递归遍历右子树
   回溯操作：弹出当前节点（栈顶指针减1）
下面是代码的具体实现：
![[Pasted image 20250626003231.png]]
![[Pasted image 20250626003301.png]]
### 知识点：
二叉树、dfs、回溯