![[Pasted image 20250530162855.png]]
### 思路：

看到这道题我首先想到的是当时回文数的判断(通过循环将该数字各位从后往前取出来，并生成出与原数数字倒置的新数，再与原数比较是否相等即可)，但这道题是字符串且寻找其子串是否为回文串，明显不符合；要解决这个问题，*首要的问题是该回文子串是从哪里开始的呢*？从回文子串的特点看不难发现，回文串的首尾一定是相等的，*那首尾相等的子串一定是回文串吗*？很显然不一定，那么我们可以把该子串当做一个字符数组，通过循环对称比较，直至下标“指针”指向同一个字符时，那如果一个字符串内有多个回文子串时，*该怎么比较他们的长短呢*？那就需要每次记下他们的长度，用二维数组存储下来即可，但二维数组真的好吗？很显然在不确定使用多少存储空间的情况下是不太合适的，可以使用如图的邻接表类似的顺序链表(自创说法)来存储。

### 步骤：

1. 先将判断从左下标到右下标之间的子串是否为回文串的代码段封装成一个***bool***函数；
2. 创建一个一维结构体数组(大小为固定的一个每次分配最小长度，为常数，后续可以用***reallc***函数扩展其存储空间)，包括子串长度以及***firstarc***指针域，注意初始化；
3. 再在函数中使用两个循环，遍历每一位，找到这一位之后的字符中是否有与其相同的字符；
4. 将二者下标以及字符串传入上述函数***bool***函数中，return为***true***时，将串的长度和该串存入上述顺序链表中(使用***malloc***函数分配一个相同大小的数组存入);return为***false***时，继续循环，直到全部遍历完成；

### 优化：
后面突然想到可以不需要多余那么多存储空间来把每一个存储下来，只需要一个一维数组，在第一次判断为真时，就分配子串长度+1（字符串记得在末尾加上\0）的空间用于存储第一个回文子串，后续只需要将串的长度与存储的MAXlen比较大小，如果比他小就把他覆盖掉，如果比他大就跳过。
下面是代码实现：
![[Pasted image 20250531002142.png]]

### 知识点：
字符串、回文
