![[Pasted image 20250620220614.png]]
### 思路：
这道题好像是今天展讲同学提到过的一道题目，对题目进行分析发现其实质类似于**一种飞行棋的玩法**，就是一个棋子落到哪个格子上后最大可以走格子所示的数字的长度，因此，问题本质是寻找一条跳跃路径，使得总跳跃次数最小化，那么**具体如何实现这样的步骤呢**？首先映入脑海中的算法便是贪心算法，因为这道题要求跳跃次数最小，即可化为每次跳跃的最远，但是**这样真的可以使跳跃次数最少吗**？显然是未必的，我们可以考虑这种情况：假如最远的位置上的数要远小于其前面一个位置上的数，那不就不是最远吗？所以我们不应该简单的将该问题处理为每一步最远，而是应该考虑跳的当前这一步如何使我能覆盖到的位置最远，**具体如何实现呢**？可以在向后遍历时使用一个一直更新的变量来记录当前能到的最大值，当然为了防止出现错误还要记录上一次能达到的最远位置当遍历到上一次跳跃能达到的最远位置时，说明本回合覆盖范围已用完，必须进行一次跳跃：增加跳跃计数器，并将上一次能跳到最远位置更新为当前能跳到的最远位置，最后**要考虑哪些边界情况呢**？首先是数组长度为1时，已在终点，故跳跃次数为0，代码中可通过直接返回0处理。
还有提前到达终点的，当上一次能到的最远位置大于n-2时，说明终点已覆盖，可提前终止遍历以优化性能在代码实现时，注意遍历范围为0到n-2（因终点无需跳跃），更新最远能覆盖到的位置时，需确保i + nums[i]不越界（题目已约束i + j < n），每次更新上一次能达到的最远距离后检查是否可提前退出。
### 细节：
- **为什么贪心策略能保证最小跳跃次数？**
    关键在于贪心策略的全局最优性：每次跳跃都基于当前可达范围内的最大覆盖潜力维护的最远能覆盖到的位置变量记录了所有已探索位置中的最远可达点，当到达当前边界时，跳跃到farthest相当于选择了当前所有可能路径中扩展能力最强的位置，这种策略确保每次跳跃都最大化覆盖范围，数学上等价于动态规划的状态转移方程：dp[k] = max(i + nums[i]) for i in [0, dp[k-1]]，题目保证可达性，因此该策略必然找到最优解。
### 步骤：
1. 首先初始化三个关键变量：跳跃次数jumps设为0，当前跳跃边界currentEnd设为0，全局最远可达位置farthest设为0；
2. 遍历数组，但只需处理到倒数第二个元素，在遍历每个位置i时，我们持续更新farthest变量，将其设置为farthest和i + nums[i]中的较大值，这样动态记录了所有可达位置中的最远跳跃潜力；
3. 当遍历指针i到达当前边界currentEnd时，说明当前跳跃回合已用尽，此时必须执行一次跳跃：增加jumps计数并将currentEnd更新为farthest，从而扩展新的覆盖范围，每次更新边界后，立即检查是否已覆盖终点（currentEnd >= n-1），若是则提前终止遍历以优化性能；
4. 返回累计的`jumps`值即为所求的最小跳跃次数。

下面是代码的具体实现：
![[Pasted image 20250620231240.png]]
### 知识点：
贪心算法、数组